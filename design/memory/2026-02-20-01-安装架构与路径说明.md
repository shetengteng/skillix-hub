# Memory Skill 安装架构与路径说明

## 概述

Memory Skill 支持两种安装模式：**全局安装**和**项目安装**。两种模式的核心区别在于 Skill 代码、Hooks、Rules 的存放位置不同，但**数据目录始终在项目本地**。

---

## 1. 两种安装模式对比

| 组件 | 项目安装（默认） | 全局安装（`--global`） |
|------|-----------------|----------------------|
| Skill 代码 | `<项目>/.cursor/skills/memory/` | `~/.cursor/skills/memory/` |
| hooks.json | `<项目>/.cursor/hooks.json` | `~/.cursor/hooks.json` |
| Rules | `<项目>/.cursor/rules/memory-rules.mdc` | `~/.cursor/rules/memory-rules.mdc` |
| 数据目录 | `<项目>/.cursor/skills/memory-data/` | `<项目>/.cursor/skills/memory-data/` |
| 嵌入模型 | `~/.memory/models/` | `~/.memory/models/` |

### 关键区别

- **项目安装**：所有组件都在项目 `.cursor/` 下，仅当前项目生效
- **全局安装**：Skill 代码 + Hooks + Rules 安装到 `~/.cursor/`，所有项目共享同一份代码和规则
- **数据目录**：无论哪种模式，数据始终在项目本地（每个项目有独立的记忆数据）
- **嵌入模型**：始终在 `~/.memory/models/`，全局共享

---

## 2. 全局安装详解

```
~/.cursor/                          ← Cursor 全局配置目录
├── hooks.json                      ← Memory Skill 的 4 个 Hook
├── rules/
│   └── memory-rules.mdc            ← Memory 行为规则
└── skills/
    └── memory/                     ← Skill 代码（全局共享）
        ├── SKILL.md
        ├── scripts/
        │   ├── service/
        │   │   ├── init/           ← 安装/更新脚本
        │   │   ├── hooks/          ← Hook 入口脚本
        │   │   ├── memory/         ← 记忆操作
        │   │   ├── config/         ← 配置管理
        │   │   └── manage/         ← 管理工具
        │   ├── storage/            ← 存储层
        │   └── core/               ← 基础设施
        └── templates/              ← 模板文件
```

**适用场景**：多个项目共用同一份 Memory Skill 代码，避免每个项目都复制一份。

**占位符替换结果**：
- `{{SKILL_PATH}}` → `~/.cursor/skills/memory`（绝对路径）
- `{{SCRIPT_PATH}}` → `~/.cursor/skills/memory/scripts`
- `{{MEMORY_DATA_PATH}}` → `~/.cursor/skills/memory-data`

---

## 3. 项目安装详解

```
<项目>/
└── .cursor/                        ← 项目级 Cursor 配置
    ├── hooks.json                  ← Memory Skill 的 4 个 Hook
    ├── rules/
    │   └── memory-rules.mdc        ← Memory 行为规则
    └── skills/
        ├── memory/                 ← Skill 代码（仅本项目）
        │   ├── SKILL.md
        │   ├── scripts/
        │   └── templates/
        └── memory-data/            ← 记忆数据（仅本项目）
            ├── config.json
            ├── MEMORY.md
            ├── daily/
            └── README.md
```

**适用场景**：单项目使用，或需要项目级定制 Skill 代码。

**占位符替换结果**：
- `{{SKILL_PATH}}` → `.cursor/skills/memory`（相对路径）
- `{{SCRIPT_PATH}}` → `.cursor/skills/memory/scripts`
- `{{MEMORY_DATA_PATH}}` → `.cursor/skills/memory-data`

---

## 4. Skill 代码 vs Skill Data 的区别

| | Skill 代码 | Skill Data |
|---|-----------|-----------|
| 内容 | Python 脚本、模板、SKILL.md | 记忆数据、配置、索引 |
| 位置 | `skills/memory/` | `skills/memory-data/` |
| 共享性 | 全局安装时多项目共享 | 始终项目独立 |
| 更新方式 | `update.py` 覆盖 | 不被更新覆盖 |
| Git 管理 | 源码仓库管理 | 应加入 `.gitignore` |

### Skill Data 目录结构

```
.cursor/skills/memory-data/
├── config.json              ← 配置（模型、阈值等）
├── MEMORY.md                ← 核心记忆（用户偏好、项目背景、重要决策）
├── facts.jsonl              ← 事实记忆（自动提取的知识点）
├── sessions.jsonl           ← 会话摘要
├── index.sqlite             ← 向量索引（语义搜索用）
├── daily/
│   └── YYYY-MM-DD.jsonl     ← 每日记忆
└── logs/
    └── YYYY-MM-DD.log       ← 运行日志
```

---

## 5. 安装命令

### 首次安装

```bash
# 项目安装（默认）
python3 skills/memory/scripts/service/init/index.py

# 全局安装
python3 skills/memory/scripts/service/init/index.py --global

# 跳过模型下载（加快安装）
python3 skills/memory/scripts/service/init/index.py --skip-model

# 指定项目路径
python3 skills/memory/scripts/service/init/index.py --project-path /path/to/project
```

### 更新已安装的 Skill

```bash
# 项目级更新
python3 <源码>/skills/memory/scripts/service/init/update.py \
  --source <源码>/skills/memory \
  --project-path <项目路径>

# 全局更新
python3 <源码>/skills/memory/scripts/service/init/update.py \
  --source <源码>/skills/memory \
  --global
```

**update.py 会**：覆盖 Skill 代码、合并 Hooks、更新 Rules
**update.py 不会**：修改数据目录、config.json、MEMORY.md、*.jsonl

---

## 6. 已知问题

### 全局安装时数据目录路径不一致

**现象**：全局模式下 `{{MEMORY_DATA_PATH}}` 被替换为 `~/.cursor/skills/memory-data`，但 `init_memory_dir()` 始终在 `<项目>/.cursor/skills/memory-data/` 创建数据目录。

**影响**：Hooks 脚本和 Rules 中引用的数据路径（`~/.cursor/skills/memory-data`）与实际数据目录（`<项目>/.cursor/skills/memory-data/`）不匹配。

**根因**：`index.py` 第 46 行设置 `memory_data_rel = ~/.cursor/skills/memory-data`，但第 85 行 `init_memory_dir(project_path)` 使用 `_DEFAULTS["paths"]["data_dir"]`（即 `.cursor/skills/memory-data`）拼接 `project_path`。

**建议**：数据目录应始终使用项目相对路径 `.cursor/skills/memory-data`，因为记忆数据是项目级的。全局安装时 `{{MEMORY_DATA_PATH}}` 也应替换为 `.cursor/skills/memory-data` 而非 `~/.cursor/skills/memory-data`。

---

## 7. 全局安装的并发安全性分析

全局安装时，多个项目共享同一份 Skill 代码（`~/.cursor/skills/memory/`），但各自有独立的数据目录。以下分析多项目同时使用时的并发风险。

### 7.1 架构层面：天然隔离

```
~/.cursor/skills/memory/          ← 共享代码（只读）
    ├── scripts/                  ← 所有项目调用同一份脚本
    └── templates/                ← 只在安装时使用

项目 A/.cursor/skills/memory-data/ ← 项目 A 独立数据
项目 B/.cursor/skills/memory-data/ ← 项目 B 独立数据
```

**关键点**：Skill 代码是**只读**的，运行时不修改。每个项目的数据目录完全独立，不同项目之间不存在数据竞争。

### 7.2 同一项目内的并发场景

在同一项目中，以下场景可能产生并发写入：

| 场景 | 写入目标 | 并发风险 |
|------|---------|---------|
| 两个 Cursor 窗口同时打开同一项目 | 同一份 `daily/*.jsonl` | **有风险** |
| preCompact + 用户手动保存同时触发 | `daily/*.jsonl` | **有风险** |
| sessionEnd 同步 + 管理工具操作 | `index.sqlite` | **有风险** |
| 管理工具 edit/delete | `daily/*.jsonl` | 已有 FileLock 保护 |

### 7.3 当前的并发保护机制

**已有保护**：
- 管理工具（`cmd_edit.py`、`cmd_delete.py`）使用 `FileLock` 互斥锁
- 锁文件位于 `memory-data/.manage.lock`
- 基于 `fcntl.flock`（Unix），超时 10 秒

**未保护的写入操作**：

| 脚本 | 写入方式 | 是否加锁 |
|------|---------|---------|
| `save_fact.py` | `open(file, "a")` 追加 | 无锁 |
| `save_summary.py` | `open(file, "a")` 追加 | 无锁 |
| `load_memory.py` | `open(file, "a")` 追加 session_start 日志 | 无锁 |
| `sync_and_cleanup.py` | `open(file, "a")` 追加 session_end 日志 | 无锁 |
| `sync_index.py` | SQLite 写入 | 依赖 SQLite 内置锁 |

### 7.4 风险评估

**低风险（JSONL 追加写入）**：
- POSIX 系统上，小于 `PIPE_BUF`（通常 4096 字节）的 `write()` 调用对以 `O_APPEND` 打开的文件是原子的
- 每条 JSONL 记录通常远小于 4096 字节
- 因此 `save_fact.py` 和 `save_summary.py` 的并发追加在实践中是安全的
- 但严格来说，Python 的 `file.write()` 不保证单次系统调用，极端情况下可能出现行交错

**中风险（SQLite 并发写入）**：
- `sync_index.py` 依赖 SQLite 内置的文件锁（WAL 模式下支持并发读，但写入仍串行）
- 两个 sessionEnd 同时触发 sync_index 时，SQLite 会自动排队，但可能因锁等待超时失败

**低风险（MEMORY.md 编辑）**：
- 由 Agent 手动编辑，不太可能同时在两个窗口编辑同一文件
- 但如果发生，后写入的会覆盖先写入的内容

### 7.5 不同项目间的并发

**无风险**：不同项目的数据目录完全独立，即使同时运行也互不影响。

```
项目 A: save_fact.py → 项目A/.cursor/skills/memory-data/daily/2026-02-20.jsonl
项目 B: save_fact.py → 项目B/.cursor/skills/memory-data/daily/2026-02-20.jsonl
```

共享的 Skill 代码是只读的，不存在写入竞争。

### 7.6 总结

| 维度 | 风险等级 | 说明 |
|------|---------|------|
| 不同项目并发 | 无风险 | 数据目录完全隔离 |
| 同项目 JSONL 追加 | 低风险 | POSIX 原子追加，实践中安全 |
| 同项目 SQLite 同步 | 中风险 | 依赖 SQLite 内置锁，可能超时 |
| 同项目 MEMORY.md 编辑 | 低风险 | 手动触发，极少并发 |
| 管理工具操作 | 已保护 | FileLock 互斥 |

---

## 8. Memory-Data 全局安装的可能性分析

### 8.1 当前设计：数据始终在项目本地

当前实现中，无论是项目安装还是全局安装，`init_memory_dir()` 始终将数据目录创建在 `<项目>/.cursor/skills/memory-data/`。这是因为：

- `init_memory_dir(project_path)` 使用 `_DEFAULTS["paths"]["data_dir"]`（值为 `.cursor/skills/memory-data`）拼接 `project_path`
- 运行时的 `get_memory_dir(project_path)` 也使用同样的逻辑
- 所有 Hook 脚本通过 `get_project_path(event)` 获取当前项目路径，再定位数据目录

### 8.2 全局 Memory-Data 的理论场景

将 memory-data 放在全局（如 `~/.cursor/skills/memory-data/`）意味着**所有项目共享同一份记忆数据**。

**可能的需求**：
- 用户希望跨项目保留统一的偏好设置（如编码风格、工具选择）
- 用户希望在项目 A 记住的知识在项目 B 也能自动加载
- 减少每个项目的初始化步骤

### 8.3 为什么当前不支持

**数据隔离需求**：
- 不同项目的技术栈、架构决策、上下文完全不同
- 项目 A 的 "使用 PostgreSQL" 对项目 B（可能用 MongoDB）是噪音
- 混合数据会降低记忆检索的精度和相关性

**路径解析问题**：
- Hook 脚本通过 `event["workspace_roots"]` 获取当前项目路径
- 如果数据在全局，所有项目的 Hook 写入同一目录，session_start/session_end 日志会混杂
- `load_memory.py` 无法区分哪些记忆属于当前项目

**并发风险升级**：
- 项目本地数据时，不同项目天然隔离
- 全局数据时，多个项目同时写入同一份 JSONL 和 SQLite，并发风险从"无"升级为"高"

**搜索质量下降**：
- 向量索引混合了所有项目的数据
- 语义搜索结果会包含不相关项目的记忆
- FTS 搜索也会产生大量误匹配

### 8.4 如果要实现全局 Memory-Data

如果未来确实需要支持，建议采用**分层架构**而非简单的全局目录：

```
~/.cursor/skills/memory-data/          ← 全局层
├── config.json                        ← 全局配置
├── MEMORY.md                          ← 全局核心记忆（用户偏好）
├── global-facts.jsonl                 ← 跨项目通用事实
└── index.sqlite                       ← 全局索引

<项目>/.cursor/skills/memory-data/      ← 项目层
├── config.json                        ← 项目配置（覆盖全局）
├── MEMORY.md                          ← 项目核心记忆
├── daily/                             ← 项目事实
├── sessions.jsonl                     ← 项目会话
└── index.sqlite                       ← 项目索引
```

**加载策略**：
1. 先加载全局 MEMORY.md（用户偏好）
2. 再加载项目 MEMORY.md（项目背景）
3. 搜索时同时查询全局和项目索引，项目结果优先

**写入策略**：
- 用户偏好类（O 类型）→ 全局
- 项目事实类（W/B 类型）→ 项目本地
- 会话摘要 → 项目本地

**需要的改动**：
- `get_memory_dir()` 需要支持返回全局和项目两个路径
- `load_memory.py` 需要合并两层数据
- `save_fact.py` 需要根据 memory_type 决定写入位置
- `sync_index.py` 需要维护两个 SQLite 索引
- `search_memory.py` 需要跨索引搜索并合并结果

### 8.5 结论

| 维度 | 项目本地（当前） | 全局安装 | 分层架构（建议） |
|------|----------------|---------|----------------|
| 数据隔离 | 完全隔离 | 无隔离 | 按层隔离 |
| 并发安全 | 天然安全 | 高风险 | 需额外锁机制 |
| 搜索精度 | 高 | 低 | 中高 |
| 跨项目共享 | 不支持 | 完全共享 | 选择性共享 |
| 实现复杂度 | 低 | 低 | 中高 |
| 推荐程度 | **当前最佳** | 不推荐 | 未来可选 |

**当前建议**：保持数据在项目本地的设计。如果需要跨项目共享用户偏好，可以考虑未来实现分层架构，但优先级不高。

---

## 9. 全局安装后新项目是否自动生效

### 9.1 结论：部分自动生效

全局安装后，打开一个新项目时：

| 功能 | 是否自动生效 | 说明 |
|------|------------|------|
| Hook 触发 | 是 | `~/.cursor/hooks.json` 全局生效 |
| Rules 加载 | 是 | `~/.cursor/rules/memory-rules.mdc` 全局生效 |
| SKILL.md 识别 | 是 | `~/.cursor/skills/memory/SKILL.md` 全局生效 |
| 数据目录创建 | **部分自动** | Hook 脚本会按需创建 |
| MEMORY.md 创建 | **不会** | 需要手动运行 init |
| config.json 创建 | **不会** | 需要手动运行 init |
| 记忆加载 | **空** | 新项目没有历史记忆 |

### 9.2 详细分析

#### Hook 和 Rules：自动生效

全局安装后，`~/.cursor/hooks.json` 和 `~/.cursor/rules/memory-rules.mdc` 对所有项目生效。当你在新项目中打开 Cursor 时：

1. **sessionStart** → 触发 `load_memory.py`
2. **preCompact** → 触发 `flush_memory.py`
3. **stop** → 触发 `prompt_session_save.py`
4. **sessionEnd** → 触发 `sync_and_cleanup.py`

#### 数据目录：按需自动创建（部分）

Hook 脚本中有 `os.makedirs(..., exist_ok=True)` 调用，会自动创建缺失的目录：

- `load_memory.py` → 创建 `daily/` 目录
- `flush_memory.py` → 创建 `memory-data/` 目录
- `prompt_session_save.py` → 创建 `memory-data/` 目录
- `sync_and_cleanup.py` → 创建 `daily/` 目录

但这些脚本**不会**创建：
- `MEMORY.md`（核心记忆文件）
- `config.json`（配置文件）
- `README.md`（说明文件）

#### 新项目的首次会话流程

```
新项目首次打开 Cursor
 ↓
sessionStart Hook 触发
 ↓
load_memory.py 执行：
 1. get_memory_dir() → <新项目>/.cursor/skills/memory-data/
 2. 检查 MEMORY.md → 不存在，跳过
 3. 检查 daily/ → 不存在，无事实
 4. 检查 sessions.jsonl → 不存在，无摘要
 5. 返回空上下文
 6. log_session_start() → 创建 daily/ 目录，写入 session_start 日志
 ↓
Agent 正常工作（无历史记忆）
 ↓
preCompact 触发（如果对话够长）：
 1. makedirs(memory-data/) → 确保目录存在
 2. 生成 [Memory Flush] 提示
 3. Agent 调用 save_fact.py → 写入 daily/YYYY-MM-DD.jsonl
 ↓
stop 触发（任务完成）：
 1. makedirs(memory-data/) → 确保目录存在
 2. 生成 [Session Save] 提示
 3. Agent 调用 save_summary.py → 写入 sessions.jsonl
 ↓
sessionEnd 触发：
 1. sync_index.py → 同步到 index.sqlite
 2. 写入 session_end 日志
```

### 9.3 缺失的部分

新项目自动生效后，以下内容需要手动初始化：

**MEMORY.md 不会自动创建**：
- `load_memory.py` 只读取，不创建
- 用户说"记住这个"时，Agent 会尝试编辑 MEMORY.md，但文件不存在
- Agent 可以自行创建文件，但不会使用标准模板

**config.json 不会自动创建**：
- 所有脚本使用 `Config` 类，会 fallback 到 `_DEFAULTS`
- 功能正常，但无法持久化项目级配置修改
- 用户执行 `config set` 时会自动创建

### 9.4 建议：为新项目添加自动初始化

可以在 `load_memory.py`（sessionStart Hook）中增加轻量初始化逻辑：

```python
# 在 load_context() 之前
memory_md_path = os.path.join(memory_dir, MEMORY_MD)
if not os.path.exists(memory_md_path):
    # 首次使用，创建默认 MEMORY.md
    os.makedirs(memory_dir, exist_ok=True)
    with open(memory_md_path, "w", encoding="utf-8") as f:
        f.write("# 核心记忆\n\n## 用户偏好\n\n## 项目背景\n\n## 重要决策\n")
```

这样新项目在首次会话时就能自动完成最小化初始化，无需手动运行 `init/index.py`。

### 9.5 总结

| 场景 | 是否需要手动操作 |
|------|----------------|
| 全局安装后打开新项目 | Hook/Rules/SKILL.md 自动生效，数据目录按需创建，但 MEMORY.md 和 config.json 不会自动创建 |
| 新项目中保存事实 | 自动工作（save_fact.py 会创建 daily/ 目录） |
| 新项目中保存摘要 | 自动工作（save_summary.py 会创建 memory-data/ 目录） |
| 新项目中用户说"记住" | Agent 需要自行创建 MEMORY.md（无标准模板） |
| 新项目中修改配置 | config set 会自动创建 config.json |
| 完整初始化（推荐） | 运行 `init/index.py --project-path <新项目>` |
