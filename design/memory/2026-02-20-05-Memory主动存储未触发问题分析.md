# Memory Skill 主动存储未触发问题分析

## 问题描述

**问题 1：主动存储未触发**

上次会话中，AI 在完成 commit + push 后说"关于测试放在 tests 目录下这个原则，我记下来了"，但实际并未将该原则持久化到记忆系统。直到用户追问"你记录到哪里了"，AI 才意识到遗漏并执行了 `save_fact.py`。

核心问题：AI 为什么没有在任务完成时主动存储重要事实，而是需要用户二次提醒？

**问题 2：日志缺失**

项目日志 `.cursor/skills/memory-data/logs/2026-02-20.log` 中只有 `save_fact` 和 `save_summary` 的写入记录，没有 `load_memory` 的加载记录。无法从日志中看出每次会话开始时预加载了哪些内容。

---

## 安装状态确认

经检查，全局安装是**完整的**：

| 组件 | 路径 | 状态 |
|------|------|------|
| hooks.json | `~/.cursor/hooks.json` | 已安装，4 个 Hook 均配置 |
| memory-rules.mdc | `~/.cursor/rules/memory-rules.mdc` | 已安装，路径已替换 |
| Skill 代码 | `~/.cursor/skills/memory/` | 已安装 |
| 项目数据目录 | `<project>/.cursor/skills/memory-data/` | 已创建 |

hooks.json 中的 4 个 Hook 命令路径均指向 `~/.cursor/skills/memory/scripts/...`，路径正确。

---

## 问题 1 根因分析：主动存储未触发

### 1. Memory Skill 的存储触发机制是被动的

Memory Skill 设计了 4 个 Hook 触发点：

| Hook | 触发时机 | 作用 |
|------|---------|------|
| `sessionStart` | 会话开始 | 加载记忆上下文 |
| `preCompact` | 上下文压缩前 | 注入 `[Memory Flush]`，引导 AI 提取事实 |
| `stop` | 任务完成（status=completed） | 注入 `[Session Save]`，引导 AI 保存摘要 |
| `sessionEnd` | 会话彻底关闭 | 同步索引、清理日志 |

关键点：**没有任何 Hook 在"AI 完成一个子任务"时触发**。`stop` Hook 只在整个会话的最终 status=completed 时触发一次，而不是每完成一个子任务就触发。

### 2. 会话内实时存储完全依赖 AI 的"自觉"

在一个会话的中间过程中（如完成 commit 后继续处理其他任务），Memory Skill 没有任何机制提醒 AI 去保存事实。AI 需要：

1. 自己判断"这个信息值得记住"
2. 自己决定调用 `save_fact.py`
3. 在没有任何系统提示的情况下完成上述两步

但 SKILL.md 和 `memory-rules.mdc` 中的指导都是围绕**系统消息触发**的：

- "当收到 `[Memory Flush]` 开头的消息时..."
- "当收到 `[Session Save]` 开头的消息时..."
- "当用户说'记住这个'时..."

**没有一条规则告诉 AI：在任务执行过程中，如果发现了重要的事实/决策/原则，应该主动调用 save_fact.py 保存。**

### 3. `preCompact` 触发条件太晚

`preCompact` 只在上下文使用率接近阈值时触发。对于短会话或中等长度会话，这个 Hook 可能永远不会触发。这意味着：

- 短会话：只靠 `stop` Hook 在结束时保存摘要
- 中等会话：同上，`preCompact` 未触发
- 长会话：`preCompact` 触发，但可能已经丢失了早期的重要上下文

### 4. `stop` Hook 的 `[Session Save]` 只引导保存摘要

查看 `prompt_session_save.py` 的模板，`[Session Save]` 的主要指令是"生成会话摘要"，对事实提取的指导是附带的（"如果 preCompact 未触发，同时提取关键事实"）。这意味着：

- 摘要是粗粒度的，不会逐条记录每个重要事实
- 如果会话中有多个重要决策，摘要可能只提及部分
- "我记下来了"这类 AI 在会话中间说的话，到 stop 时可能已经被遗忘

---

## 问题 2 根因分析：日志缺失

### logger 的日志目录基于 `os.getcwd()`

`logger.py` 中 `_get_log_dir()` 的逻辑：

```python
data_dir = _DEFAULTS["paths"]["data_dir"]  # ".cursor/skills/memory-data"
_LOG_DIR = os.path.join(os.getcwd(), data_dir, "logs")
```

当 Hook 从全局 `~/.cursor/hooks.json` 触发时：
- `save_fact.py` 和 `save_summary.py` 是 **AI 在会话中主动调用**的，此时 cwd 是项目目录，所以日志写入了 `<project>/.cursor/skills/memory-data/logs/`
- `load_memory.py` 是 **sessionStart Hook 自动调用**的，此时 cwd 可能是项目目录也可能不是

但更关键的问题是：**即使 load_memory.py 的日志正确写入了项目目录，它只记录了"加载了多少条"，没有记录"加载了哪些内容"**。

查看 `load_memory.py` 中的日志输出：

```python
log.info("加载 MEMORY.md (%d 字符)", len(content))
log.info("加载近期事实 %d 条（从 daily/ 目录）", len(recent_facts))
log.info("上下文输出 %d 字符", len(context))
```

这些日志只记录了数量级信息，没有记录具体加载了哪些事实、哪个会话摘要。用户无法从日志中确认"AI 在会话开始时到底看到了什么"。

### sessionStart Hook 的输出不可见

`load_memory.py` 作为 sessionStart Hook，其输出通过 `{"additional_context": "..."}` 注入到 AI 的上下文中。但这个注入过程对用户是不可见的——用户看不到 Hook 返回了什么，也看不到 AI 收到了什么上下文。

---

## 触发链路全景图

```
┌─────────────────────────────────────────────────────────────┐
│                    当前实际触发链路                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ① sessionStart Hook (自动)                                 │
│     └→ load_memory.py                                       │
│        ├→ 读取 MEMORY.md + daily/*.jsonl + sessions.jsonl   │
│        ├→ 输出 {"additional_context": "..."} 注入 AI 上下文  │
│        └→ 日志：只记录条数，不记录内容 ← 问题2               │
│                                                             │
│  ② 会话进行中 (AI 执行任务)                                  │
│     └→ 无任何自动触发机制                                    │
│        └→ AI 说"记下来了"但没有实际调用 save_fact ← 问题1    │
│                                                             │
│  ③ preCompact Hook (上下文压缩前，短会话不触发)               │
│     └→ flush_memory.py                                      │
│        └→ 注入 [Memory Flush]，引导 AI 提取事实              │
│                                                             │
│  ④ stop Hook (status=completed)                             │
│     └→ prompt_session_save.py                               │
│        └→ 注入 [Session Save]，引导 AI 保存摘要+补充事实     │
│                                                             │
│  ⑤ sessionEnd Hook (会话关闭)                               │
│     └→ sync_and_cleanup.py                                  │
│        └→ 同步索引 + 清理日志                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 为什么上次会话最终还是保存成功了

查看 `daily/2026-02-20.jsonl` 第 8 行：

```json
{"id": "log-143509669-s86d", "type": "fact", "memory_type": "O", "content": "项目原则：测试文件必须放在 tests/ 目录下...", "timestamp": "2026-02-20T14:35:09Z"}
```

时间戳 14:35，而会话摘要（sessions.jsonl 第 4 条）时间戳 14:36。说明 AI 是在用户追问后才手动调用 `save_fact.py` 保存的，然后会话结束时 `[Session Save]` 触发又保存了摘要。

AI 确实有能力调用 `save_fact.py`，只是缺少主动触发的机制。

---

## MEMORY.md 的更新机制

### MEMORY.md 是什么

`MEMORY.md` 是 Memory Skill 的**核心记忆文件**，定位为长期不变的、高价值的信息存储。它与 `daily/*.jsonl`（流水式事实日志）和 `sessions.jsonl`（会话摘要）是不同的存储层。

### 当前 MEMORY.md 的内容

```markdown
# 核心记忆

## 用户偏好

## 项目背景

## 重要决策
```

内容为空——从未被写入过任何实际内容。

### MEMORY.md 的写入方式

根据代码分析，MEMORY.md 的写入**完全依赖 AI 手动编辑文件**，没有任何脚本会自动写入：

| 写入方式 | 触发条件 | 代码位置 |
|---------|---------|---------|
| AI 直接编辑文件 | 用户说"记住这个" | SKILL.md 第 101-103 行 |
| 首次自动创建 | MEMORY.md 不存在时 | `load_memory.py` `_ensure_memory_md()` |
| init 安装时创建 | 首次安装 | `helpers.py` `init_memory_dir()` |

**关键发现**：`save_fact.py` 不会写入 MEMORY.md，它只写入 `daily/YYYY-MM-DD.jsonl`。`save_summary.py` 也不会写入 MEMORY.md，它只写入 `sessions.jsonl`。

### 你要求"记住"的内容去了哪里

上次会话中，用户追问后 AI 调用了 `save_fact.py`，该事实被写入了 `daily/2026-02-20.jsonl`：

```json
{"id": "log-143509669-s86d", "type": "fact", "memory_type": "O", "content": "项目原则：测试文件必须放在 tests/ 目录下..."}
```

这条记录**不在 MEMORY.md 中**，而是在 daily jsonl 中。下次会话开始时，`load_memory.py` 会从 daily 目录加载近期事实，所以 AI 仍然能看到这条信息。但它不会出现在 MEMORY.md 的"核心记忆"中。

### MEMORY.md 与 daily/*.jsonl 的关系

```
MEMORY.md（核心记忆）          daily/*.jsonl（流水事实）
├── 手动编辑                   ├── save_fact.py 自动写入
├── 长期不变的高价值信息         ├── 按天滚动，有保留期限
├── 每次会话都加载              ├── 按配置加载最近 N 天
└── 用户说"记住这个"时写入      └── [Memory Flush] / [Session Save] 时写入
```

### 存在的问题

1. **MEMORY.md 从未被使用**：当前为空，说明 AI 从未执行过"直接编辑 MEMORY.md"的操作
2. **触发条件过窄**：只有用户明确说"记住这个"时才会写入 MEMORY.md，但用户很少会这样说
3. **save_fact 与 MEMORY.md 断裂**：通过 `[Memory Flush]` 和 `[Session Save]` 保存的事实都进了 daily jsonl，不会进入 MEMORY.md
4. **缺少自动提炼机制**：没有脚本将 daily 中的高频/高置信度事实自动提炼到 MEMORY.md

---

## `stop` vs `sessionEnd`：是否需要在 sessionEnd 也触发 Session Save

### 当前 `stop` 和 `sessionEnd` 的区别

| 属性 | `stop` | `sessionEnd` |
|------|--------|-------------|
| 触发时机 | Agent 循环结束 | Composer 会话彻底关闭 |
| 触发条件 | status=completed/aborted/error | reason=completed/aborted/error/window_close/user_close |
| 输出能力 | `followup_message`（可让 AI 继续执行） | 无（fire-and-forget） |
| AI 是否在线 | 是，AI 仍可执行工具 | 否，AI 已退出 |
| 当前用途 | 注入 `[Session Save]` | 同步索引 + 清理日志 |

### `stop` Hook 的过滤逻辑

`prompt_session_save.py` 第 68 行：

```python
if status != "completed":
    log.info("status 非 completed，跳过摘要保存提示")
    print(json.dumps({}))
    return
```

**只有 status=completed 时才触发 Session Save**。这意味着：
- 用户手动中止（aborted）→ 不保存
- 出错（error）→ 不保存
- 只有正常完成 → 保存

### 在 `sessionEnd` 触发 Session Save 是否可行

**不可行**，原因：

1. **`sessionEnd` 是 fire-and-forget**：根据 Cursor 文档，sessionEnd 的输出不被使用（"Response is logged but not used"）。即使返回 `followup_message`，也不会被注入到任何地方。

2. **AI 已退出**：sessionEnd 触发时，Agent 循环已经结束，AI 无法再执行 `save_fact.py` 或 `save_summary.py`。Session Save 需要 AI 来分析会话内容并生成摘要，这在 sessionEnd 阶段无法完成。

3. **sessionEnd 没有会话上下文**：它只收到 `reason`、`duration_ms` 等元数据，没有会话内容，无法生成摘要。

### 但 `sessionEnd` 可以做兜底存储

虽然不能让 AI 生成摘要，但 `sessionEnd` 可以做一些**自动化的兜底操作**：

1. **检测 stop 是否成功保存了摘要**：读取 sessions.jsonl，检查最后一条摘要的 session_id 是否匹配当前会话。如果不匹配，说明 stop Hook 的 Session Save 没有成功执行。

2. **记录未保存警告**：如果检测到摘要缺失，在 daily.jsonl 中写入一条 `type: "warning"` 的记录，标记"本次会话未保存摘要"。

3. **强制同步**：确保所有已写入的 jsonl 数据都同步到 SQLite 索引。

### 真正应该优化的是 `stop` Hook

与其在 sessionEnd 做兜底，不如让 `stop` Hook 更可靠：

1. **放宽 status 过滤**：除了 `completed`，`aborted` 状态也应该触发 Session Save（用户中止时可能已经完成了大量工作）
2. **增加重试机制**：如果 AI 没有执行 save_summary，利用 `loop_limit` 再次提醒

---

## 问题总结

| 层级 | 问题 | 影响 |
|------|------|------|
| **设计层** | 无"任务中实时存储"的规则或提示 | AI 在子任务完成时不会主动保存事实 |
| **设计层** | 存储触发完全依赖 Hook 注入的系统消息 | 会话中间的重要事实可能被遗漏 |
| **设计层** | `preCompact` 对短/中会话无效 | 大量重要事实可能在会话结束前丢失 |
| **设计层** | MEMORY.md 从未被实际使用，核心记忆为空 | 长期高价值信息没有持久化存储 |
| **设计层** | `stop` Hook 只在 status=completed 时触发 | 用户中止的会话不保存摘要 |
| **设计层** | save_fact 与 MEMORY.md 断裂，缺少自动提炼 | daily 中的重要事实不会进入核心记忆 |
| **日志层** | `load_memory.py` 只记录加载条数，不记录内容 | 无法确认 AI 会话开始时看到了什么 |
| **日志层** | sessionStart Hook 的输出对用户不可见 | 无法验证记忆加载是否正常工作 |

---

## Cursor Hooks 全量对比分析

### 当前 Memory Skill 已使用的 Hook（4 个）

| Hook | 用途 | 输出方式 |
|------|------|---------|
| `sessionStart` | 加载记忆上下文 | `additional_context` |
| `preCompact` | 注入 `[Memory Flush]` | `user_message` |
| `stop` | 注入 `[Session Save]` | `followup_message` |
| `sessionEnd` | 同步索引、清理日志 | 无（fire-and-forget） |

### Cursor 支持的全部 Hook 事件（20 个）

根据 Cursor Hooks 官方文档，完整的 Hook 事件列表如下：

**Agent Hook（18 个）：**

| Hook | 触发时机 | 输入关键字段 | 可用输出 | Memory 可用性 |
|------|---------|-------------|---------|--------------|
| `sessionStart` | 会话创建 | session_id, composer_mode | env, additional_context, continue | **已使用** |
| `sessionEnd` | 会话关闭 | reason, duration_ms | 无 | **已使用** |
| `preCompact` | 上下文压缩前 | context_usage_percent, message_count | user_message | **已使用** |
| `stop` | Agent 循环结束 | status, loop_count | followup_message | **已使用** |
| `preToolUse` | 工具执行前 | tool_name, tool_input | decision, updated_input | 可用 |
| `postToolUse` | 工具成功执行后 | tool_name, tool_output, duration | updated_mcp_tool_output | **高价值** |
| `postToolUseFailure` | 工具执行失败 | tool_name, error_message, failure_type | 无 | 低价值 |
| `subagentStart` | 子代理启动前 | subagent_type, prompt | decision | 低价值 |
| `subagentStop` | 子代理完成 | subagent_type, status, result | followup_message | 可用 |
| `beforeShellExecution` | Shell 命令前 | command, cwd | permission, agent_message | 低价值 |
| `afterShellExecution` | Shell 命令后 | command, output, duration | 无 | 可用 |
| `beforeMCPExecution` | MCP 工具前 | tool_name, tool_input | permission | 低价值 |
| `afterMCPExecution` | MCP 工具后 | tool_name, result_json, duration | 无 | 低价值 |
| `afterFileEdit` | 文件编辑后 | file_path, edits | 无 | 可用 |
| `beforeReadFile` | 文件读取前 | file_path, content | permission | 低价值 |
| `beforeSubmitPrompt` | 用户提交前 | prompt, attachments | continue | 低价值 |
| `afterAgentResponse` | Agent 回复后 | text | 无 | **高价值** |
| `afterAgentThought` | Agent 思考后 | text, duration_ms | 无 | 可用 |

**Tab Hook（2 个）：**

| Hook | 触发时机 | Memory 可用性 |
|------|---------|--------------|
| `beforeTabFileRead` | Tab 补全读文件前 | 无关 |
| `afterTabFileEdit` | Tab 补全编辑后 | 无关 |

### 可补充使用的 Hook 及优化方案

#### 方案 A：`afterAgentResponse` — 实时事实提取（解决问题 1 核心方案）

**价值：极高** — 直接解决"任务中主动存储"问题。

`afterAgentResponse` 在 Agent 每次完成一条回复后触发，输入包含完整的 `text`（助手回复文本）。

**设计思路**：

```
afterAgentResponse 触发
    ↓
hook 脚本分析 agent 回复文本
    ↓
检测是否包含重要事实信号（关键词/模式匹配）
    ↓
如果检测到 → 注入提示让 AI 保存事实
如果未检测到 → 静默跳过
```

**检测信号示例**：
- "记下来了"、"已记录"、"这个原则"、"这个规范"
- "决定使用"、"选择了"、"确定方案"
- "重要：..."、"注意：..."
- commit 消息中的关键决策

**局限**：`afterAgentResponse` 当前文档显示输出字段为空（无 `followup_message`），只能用于观测。如果未来支持输出，则可以直接注入提示。当前可作为审计日志使用。

#### 方案 B：`postToolUse` + matcher — 基于工具行为的事实捕获

**价值：高** — 在关键操作完成后自动触发记忆检查。

`postToolUse` 在任何工具成功执行后触发，可通过 `matcher` 过滤特定工具。

**设计思路**：

```json
{
  "postToolUse": [
    {
      "command": "python3 ~/.cursor/skills/memory/scripts/service/hooks/check_memory.py",
      "matcher": "Shell"
    }
  ]
}
```

hook 脚本分析 `tool_input` 和 `tool_output`：
- 如果是 `git commit` → 从 commit message 中提取决策
- 如果是 `save_fact.py` / `save_summary.py` → 跳过（避免递归）
- 如果是其他关键操作 → 记录到审计日志

**优势**：
- 可以精确捕获 commit 时的决策信息
- 通过 matcher 过滤，只在 Shell 工具执行后触发，性能开销小
- `tool_output` 包含完整输出，信息量大

**局限**：
- `postToolUse` 的输出只有 `updated_mcp_tool_output`（仅对 MCP 工具有效），无法向 Agent 注入消息
- 只能用于审计/后台存储，不能提醒 AI 去保存

#### 方案 C：`stop` Hook 增强 — 利用 `followup_message` 循环

**价值：中** — 改进现有方案，但不解决实时性问题。

当前 `stop` Hook 的 `loop_limit` 设为 1，意味着 `[Session Save]` 只触发一次。可以考虑：

1. 在 `[Session Save]` 的 followup_message 中，除了要求保存摘要，还明确要求逐条提取所有重要事实
2. 将 `loop_limit` 适当增大（如 2），允许第一轮保存摘要，第二轮补充遗漏的事实

**局限**：仍然只在会话结束时触发，不解决会话中间的实时存储问题。

#### 方案 D：`afterAgentThought` — 思考过程中的事实检测

**价值：中** — 可以在 AI 思考阶段就捕获决策意图。

`afterAgentThought` 在 Agent 完成思考后触发，输入包含完整的思考文本。思考文本中通常包含 AI 的推理过程和决策判断，是提取事实的好来源。

**局限**：同 `afterAgentResponse`，当前输出字段为空，只能用于观测/审计。

#### 方案 E：`afterShellExecution` — Shell 命令审计

**价值：低-中** — 作为补充手段。

`afterShellExecution` 在 Shell 命令执行后触发，输入包含 `command` 和 `output`。可以：
- 检测 `git commit` 命令，从输出中提取 commit hash 和 message
- 检测 `npm install` / `pip install` 等，记录依赖变更

**局限**：信息粒度太细，大部分 Shell 命令不值得记录。

---

### 推荐优化方案组合

| 优先级 | 方案 | Hook | 目标 |
|--------|------|------|------|
| **P0** | 规则层修复 | 无需新 Hook | 在 `memory-rules.mdc` 中增加"主动存储"规则 |
| **P1** | 方案 B | `postToolUse` + matcher="Shell" | 捕获 git commit 等关键操作的决策信息 |
| **P1** | 日志增强 | 现有 `sessionStart` | 增强 load_memory.py 日志输出具体内容 |
| **P2** | 方案 A | `afterAgentResponse` | 实时检测 Agent 回复中的重要事实信号（观测+审计） |
| **P2** | 方案 C | 现有 `stop` | 增强 Session Save 模板，明确要求逐条提取事实 |
| **P3** | 方案 D | `afterAgentThought` | 从思考过程中提取决策意图（观测） |

---

## 建议修复方向

### P0：增加"任务中主动存储"规则

在 `memory-rules.mdc` 中增加一条规则：

> 在任务执行过程中，当 AI 识别到以下类型的信息时，应主动调用 save_fact.py 保存，无需等待系统消息：
> - 新确立的项目原则或规范
> - 重要的架构决策
> - 用户明确表达的偏好
> - 关键的 Bug 修复方案

这是成本最低、见效最快的修复。不需要新增 Hook，只需修改规则文件。

### P0：放宽 `stop` Hook 的 status 过滤（确认需要）

将 `prompt_session_save.py` 第 68 行的过滤条件从 `status == "completed"` 改为 `status in ("completed", "aborted")`，确保用户中止的会话也能保存摘要。用户中止时可能已经完成了大量工作，这些内容不应丢失。

修改位置：`skills/memory/scripts/service/hooks/prompt_session_save.py` 第 68 行

```python
# 当前
if status != "completed":

# 改为
if status not in ("completed", "aborted"):
```

### P1：增加 `postToolUse` Hook 捕获关键操作

新增 `postToolUse` Hook，matcher 过滤 Shell 工具，在 git commit 等关键操作后自动提取决策信息并后台保存到 daily.jsonl。

### P1：增强 load_memory.py 的日志输出

在日志中记录实际加载的内容摘要（至少记录每条事实的 id 和前 50 字符），方便排查"AI 到底看到了什么"。

### P1：`sessionEnd` 增加兜底检测

在 `sync_and_cleanup.py` 中增加逻辑：检查 sessions.jsonl 最后一条摘要的 session_id 是否匹配当前会话，如果不匹配则写入 `type: "warning"` 记录，标记"本次会话未保存摘要"。

### P2：增加 `afterAgentResponse` Hook 实时审计

在 Agent 每次回复后，检测回复文本中是否包含重要事实信号，记录到审计日志。未来如果 Cursor 支持该 Hook 的输出字段，可以升级为主动提醒 AI 保存。

### P2：增强 `stop` Hook 的 Session Save 模板

在 `[Session Save]` 模板中，明确要求 AI 逐条列出并保存所有重要事实，而不仅仅是生成摘要。

### P3：增加 MEMORY.md 自动提炼机制

在 `sessionEnd` 或定期任务中，扫描 daily jsonl 中高频出现或高置信度的事实，自动提炼到 MEMORY.md 的对应章节中。
