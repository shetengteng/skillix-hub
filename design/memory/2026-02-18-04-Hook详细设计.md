# 方案 C：Hook 详细设计

> **版本**: v1.0
> **创建日期**: 2026-02-18
> **系列**: 方案 C 设计文档 ([返回总览](./2026-02-18-01-总览与设计理念.md))

---

## 1. sessionStart Hook

**职责**：读取记忆文件，注入到 Agent 上下文。此阶段与原方案一致，不涉及 LLM 调用。

**文件**：`scripts/load_memory.py`

### 1.1 输入/输出

**输入**（stdin JSON）：
```json
{
  "type": "sessionStart",
  "conversation_id": "conv-123",
  "workspace_roots": ["/Users/user/project/myapp"],
  "transcript_path": null
}
```

**输出**（stdout JSON）：
```json
{
  "additional_context": "## 项目记忆\n\n### 核心记忆\n- 数据库：PostgreSQL\n- 语言：TypeScript\n\n### 近期事实\n- [2026-02-16] 决定使用 JWT 认证\n- [2026-02-16] API 响应时间目标 200ms"
}
```

### 1.2 实现逻辑

```python
import sys, json, os

def main():
    event = json.loads(sys.stdin.read())
    project_path = get_project_path(event)
    memory_dir = os.path.join(project_path, '.cursor/skills/memory-data')
    
    context_parts = []
    
    # 1. 读取 MEMORY.md
    memory_md = os.path.join(memory_dir, 'MEMORY.md')
    if os.path.exists(memory_md):
        with open(memory_md, 'r') as f:
            content = f.read().strip()
            if content:
                context_parts.append(f"## 核心记忆\n\n{content}")
    
    # 2. 读取近期 facts（最近 7 天，最多 15 条）
    facts_file = os.path.join(memory_dir, 'facts.jsonl')
    if os.path.exists(facts_file):
        recent_facts = read_recent_facts(facts_file, days=7, limit=15)
        if recent_facts:
            facts_text = "\n".join(
                f"- [{f['type']}] {f['content']}" for f in recent_facts
            )
            context_parts.append(f"## 近期事实\n\n{facts_text}")
    
    # 3. 读取最近一次会话摘要
    sessions_file = os.path.join(memory_dir, 'sessions.jsonl')
    if os.path.exists(sessions_file):
        last_session = read_last_entry(sessions_file)
        if last_session:
            context_parts.append(
                f"## 上次会话\n\n"
                f"- 主题：{last_session.get('topic', '未知')}\n"
                f"- 摘要：{last_session.get('summary', '无')}"
            )
    
    # 4. 记录 session_start 事件
    log_event(memory_dir, "session_start", {
        "workspace": project_path
    })
    
    # 5. 输出
    additional_context = "\n\n".join(context_parts) if context_parts else ""
    print(json.dumps({"additional_context": additional_context}))

if __name__ == "__main__":
    main()
```

### 1.3 特点

| 属性 | 值 |
|------|-----|
| 超时时间 | 10 秒 |
| 是否调用 LLM | 否（纯文件读取） |
| 失败策略 | 静默跳过（fail-open），Agent 正常工作，只是没有历史记忆 |
| 返回方式 | `additional_context`（注入到 Agent 系统上下文） |

### 1.4 加载优先级

当记忆数据较多时，需要控制加载量以避免占用过多上下文空间：

| 优先级 | 数据源 | 加载策略 |
|--------|--------|----------|
| 1（最高） | `MEMORY.md` | 全量加载 |
| 2 | 上次会话摘要 | 最近 1 条 |
| 3 | 近期 facts | 最近 7 天，最多 15 条 |
| 4（最低） | SQLite 搜索 | 按相关性排序，最多 5 条 |

---

## 2. preCompact Hook（核心变更）

**职责**：构建 flush prompt，通过 `user_message` 让 Agent 自主提取关键事实。

**与原方案的关键差异**：不再调用外部 LLM，改为让 Agent 自己提取。

**文件**：`scripts/flush_memory.py`

### 2.1 输入/输出

**输入**（stdin JSON）：
```json
{
  "type": "preCompact",
  "conversation_id": "conv-123",
  "workspace_roots": ["/Users/user/project/myapp"],
  "transcript_path": "/path/to/transcript.jsonl",
  "context_usage_percent": 85,
  "message_count": 30,
  "is_first_compaction": false
}
```

**输出**（stdout JSON）：
```json
{
  "user_message": "[Memory Flush]\n\n上下文即将压缩。请回顾当前对话，将关键事实保存到 .cursor/skills/memory-data/ 目录。\n\n写入规则：\n1. 提取关键事实（技术决策、架构选择、配置变更）\n2. 提取用户偏好（编码风格、工具选择、沟通方式）\n3. 每条事实使用 save_fact.py 写入 .cursor/skills/memory-data/daily/\n4. 格式：{\"type\":\"fact\",\"memory_type\":\"W|B|O\",\"content\":\"...\",\"entities\":[\"...\"],\"confidence\":0.8,\"timestamp\":\"...\"}\n5. 如果没有需要记住的内容，不做任何操作\n6. 完成后不需要向用户报告，静默继续"
}
```

### 2.2 Flush Prompt 模板

preCompact Hook 生成的 `user_message` 内容如下（模板变量会在运行时替换）：

> **[Memory Flush]**
>
> 上下文即将压缩（当前使用率 {usage}%，消息数 {msg_count}）。请回顾当前对话，将关键事实保存到 .cursor/skills/memory-data 目录。
>
> **写入规则**：提取关键事实（技术决策、架构选择）、用户偏好（编码风格、工具选择）、项目经历（里程碑、重要变更）
>
> **写入方式**：使用 Shell 工具，每条事实追加一行到 `.cursor/skills/memory-data/daily/YYYY-MM-DD.jsonl`
>
> **memory_type 分类**：W(客观事实) / B(项目经历) / O(用户偏好，需标注 confidence)
>
> **注意**：无需保存则不操作；静默继续，不向用户报告；不重复 MEMORY.md 已有内容

写入命令示例：

```bash
python3 .cursor/skills/memory/scripts/save_fact.py --content "事实内容" --type W --entities "相关实体" --confidence 0.9 --session conv-123
```

### 2.3 实现逻辑

```python
import sys, json, os
from datetime import datetime

def main():
    event = json.loads(sys.stdin.read())
    project_path = get_project_path(event)
    memory_dir = os.path.join(project_path, '.cursor/skills/memory-data')
    os.makedirs(memory_dir, exist_ok=True)

    now = datetime.utcnow()
    prompt = build_flush_prompt(
        usage=event.get('context_usage_percent', '?'),
        msg_count=event.get('message_count', '?'),
        date=now.strftime('%Y-%m-%d'),
        ts=now.strftime('%H%M%S'),
        iso_time=now.isoformat() + 'Z',
        conv_id=event.get('conversation_id', 'unknown')
    )
    print(json.dumps({"user_message": prompt}))

def build_flush_prompt(usage, msg_count, date, ts, iso_time, conv_id):
    """构建 flush prompt 字符串（包含写入规则、格式模板、分类说明）"""
    # 完整模板包含：写入规则、bash 命令示例、memory_type 分类、注意事项
    # 见上方 "2.2 Flush Prompt 模板" 中的完整内容
    ...

def get_project_path(event):
    roots = event.get('workspace_roots', [])
    return roots[0] if roots else os.getcwd()

if __name__ == "__main__":
    main()
```

### 2.4 特点

| 属性 | 值 |
|------|-----|
| 超时时间 | 5 秒（原方案 30 秒，因为不再等 LLM 响应） |
| 是否调用 LLM | 否（仅构建 prompt 字符串） |
| 返回方式 | `user_message`（作为用户消息注入，Agent 在完整上下文中处理） |
| 关键假设 | `user_message` 在压缩**前**注入，Agent 仍有完整上下文 |

### 2.5 flush prompt 设计考量

| 设计决策 | 理由 |
|----------|------|
| 使用 `[Memory Flush]` 前缀 | 便于 Rules 中做模式匹配，确保 Agent 识别为系统指令 |
| 包含上下文使用率和消息数 | 帮助 Agent 判断需要保存多少内容 |
| 明确写入格式和示例 | 减少 Agent 写入格式错误的概率 |
| 强调"静默继续" | 避免 Agent 向用户报告记忆操作 |
| 提醒"不要重复 MEMORY.md" | 避免 Agent 重复保存已知信息 |

---

## 3. stop Hook

**职责**：在 Agent 完成任务后，通过 `followup_message` 让 Agent 生成会话摘要。

**文件**：`scripts/prompt_session_save.py`

### 3.1 输入/输出

**输入**（stdin JSON）：
```json
{
  "type": "stop",
  "conversation_id": "conv-123",
  "workspace_roots": ["/Users/user/project/myapp"],
  "status": "completed"
}
```

**输出**（stdout JSON）：
```json
{
  "followup_message": "[Session Save]\n\n任务已完成。请生成本次会话的摘要并保存。\n\n..."
}
```

### 3.2 Save Prompt 模板

stop Hook 生成的 `followup_message` 内容如下：

> **[Session Save]**
>
> 任务已完成。请生成本次会话的摘要并保存到 .cursor/skills/memory-data/sessions.jsonl。
>
> **摘要要求**：主题（一句话）、摘要（100-200 字）、关键决策（列表）、待办事项（如有）
>
> **同时**：如果本次会话中 preCompact 未触发，请一并提取关键事实写入 `.cursor/skills/memory-data/daily/YYYY-MM-DD.jsonl`
>
> **注意**：内容太少则不操作；完成后不向用户报告

写入命令示例：

```bash
python3 .cursor/skills/memory/scripts/save_summary.py --topic "主题" --summary "摘要内容" --decisions "决策1" --todos "待办1" --session conv-123
```

### 3.3 实现逻辑

```python
import sys, json, os
from datetime import datetime

def main():
    event = json.loads(sys.stdin.read())
    status = event.get('status', '')

    if status != 'completed':
        print(json.dumps({}))
        return

    project_path = get_project_path(event)
    memory_dir = os.path.join(project_path, '.cursor/skills/memory-data')
    os.makedirs(memory_dir, exist_ok=True)

    now = datetime.utcnow()
    prompt = build_save_prompt(
        ts=now.strftime('%H%M%S'),
        conv_id=event.get('conversation_id', 'unknown'),
        iso_time=now.isoformat() + 'Z'
    )
    print(json.dumps({"followup_message": prompt}))

def build_save_prompt(ts, conv_id, iso_time):
    """构建 save prompt 字符串（包含摘要要求、格式模板）"""
    # 完整模板包含：摘要要求、bash 命令示例、事实补充提取
    # 见上方 "3.2 Save Prompt 模板" 中的完整内容
    ...

def get_project_path(event):
    roots = event.get('workspace_roots', [])
    return roots[0] if roots else os.getcwd()

if __name__ == "__main__":
    main()
```

### 3.4 特点

| 属性 | 值 |
|------|-----|
| 返回方式 | `followup_message`（让 Agent 在完成任务后继续执行一轮） |
| `loop_limit` | 1（确保只执行一次，不会无限循环） |
| 触发条件 | 仅 `status = "completed"` 时触发 |
| 失败策略 | 非正常完成（interrupted 等）时输出空 JSON，跳过摘要保存 |
| 双重职责 | 生成摘要 + 补充提取事实（如 preCompact 未触发） |

### 3.5 followup_message 机制说明

`followup_message` 与 `user_message` 的区别：

| 属性 | `user_message` | `followup_message` |
|------|---------------|-------------------|
| 使用场景 | preCompact（压缩前） | stop（任务完成后） |
| 注入时机 | 压缩操作之前 | Agent 完成当前任务之后 |
| Agent 上下文 | 完整（压缩还未发生） | 完整（刚完成任务） |
| 是否触发新一轮 | 是（作为新的用户消息） | 是（让 Agent 继续执行） |
| 循环控制 | — | 受 `loop_limit` 限制 |

---

## 4. sessionEnd Hook

**职责**：会话彻底关闭后，静默执行后台任务：同步 SQLite 索引、记录会话元数据、清理过期日志。

**与 stop 的区别**：`stop` 触发后 Agent 还会执行 `[Session Save]`，而 `sessionEnd` 在一切结束后触发，是最终的清理阶段。

**文件**：`scripts/sync_and_cleanup.py`

### 4.1 输入/输出

**输入**（stdin JSON）：
```json
{
  "session_id": "conv-123",
  "reason": "completed",
  "duration_ms": 45000,
  "is_background_agent": false,
  "final_status": "completed",
  "error_message": null,
  "conversation_id": "conv-123",
  "workspace_roots": ["/Users/user/project/myapp"]
}
```

**输出**：无（fire-and-forget，响应被记录但不使用）

### 4.2 执行任务

| 序号 | 任务 | 说明 |
|------|------|------|
| 1 | 同步 SQLite 索引 | 调用 `sync_index.py` 将新写入的 JSONL 数据增量同步到 index.sqlite |
| 2 | 记录会话元数据 | 将 `reason`、`duration_ms` 等写入 `daily/YYYY-MM-DD.jsonl` |
| 3 | 清理过期日志 | 删除超过 `LOG_RETAIN_DAYS` 天的日志文件 |

### 4.3 为什么在 sessionEnd 做索引同步

```
时间线：
  stop Hook → Agent 写入 summary/facts → sessionEnd Hook → sync_index
                                          ↑
                                  此时所有 JSONL 已写入完毕
                                  是最安全的同步时机
```

如果在 `stop` 中做同步，summary 和 facts 还没写入（Agent 还在执行 followup），索引会缺少最新数据。

### 4.4 特点

| 属性 | 值 |
|------|-----|
| 超时时间 | 30 秒（需要加载嵌入模型，首次较慢） |
| 是否调用 LLM | 否（运行 Python 脚本） |
| 输出 | 无（fire-and-forget） |
| 失败策略 | 静默失败，不影响用户 |
| 触发条件 | 任何原因的会话结束（completed/aborted/error/window_close/user_close） |

### 4.5 `reason` 字段处理

| reason | 含义 | 处理策略 |
|--------|------|----------|
| `completed` | 正常完成 | 完整同步：索引 + 元数据 + 清理 |
| `aborted` | 用户中断 | 同步索引 + 记录元数据（可能有部分 facts） |
| `error` | 出错 | 记录错误信息 + 同步索引 |
| `window_close` | 关闭窗口 | 同步索引 + 记录元数据 |
| `user_close` | 用户关闭会话 | 同步索引 + 记录元数据 |

---

## 5. Hook 功能扩展分析

除了已实现的 4 个 Hook，以下 Hook 也有潜在价值（按优先级排序）：

| Hook | 潜在用途 | 优先级 | 原因 |
|------|----------|--------|------|
| `postToolUse` | 记录 Agent 使用了哪些工具 | 低 | 数据量大，噪声多 |
| `afterAgentResponse` | 从回复中提取事实 | 低 | preCompact 已覆盖此需求 |
| `afterFileEdit` | 记录文件修改历史 | 低 | Git 已有此功能 |
| `beforeSubmitPrompt` | 在提交前注入上下文 | 中 | sessionStart 已覆盖 |

当前 4 个 Hook 已覆盖记忆系统的完整生命周期，暂不需要额外扩展。

---

## 5.5. 记忆搜索（Agent 主动调用）

**职责**：Agent 在需要时主动搜索历史记忆。

**文件**：`scripts/search_memory.py`

### 4.1 调用方式

Agent 通过 Shell 工具调用：

```bash
python3 ~/.cursor/skills/memory/scripts/search_memory.py "JWT 认证" --max-results 5
```

### 4.2 输出

```json
{
  "results": [
    {
      "content": "决定使用 JWT 认证，token 有效期 24 小时",
      "type": "W",
      "score": 0.92,
      "source": "facts.jsonl",
      "timestamp": "2026-02-16T14:30:00Z"
    }
  ]
}
```

### 4.3 特点

| 属性 | 值 |
|------|-----|
| 触发方式 | Agent 主动调用（非 Hook 触发） |
| 搜索引擎 | SQLite FTS5 + 向量相似度（混合搜索） |
| 调用时机 | 用户提到"之前讨论过"、Agent 需要历史信息时 |
| 性能 | 毫秒级响应 |

> 搜索的技术细节见 [08-SQLite索引设计](./2026-02-18-08-SQLite索引设计.md)

---

## 6. Hook 配置总览

以下是 `hooks.json` 中四个 Hook 的完整配置：

```json
{
  "version": 1,
  "hooks": {
    "sessionStart": [
      {
        "command": "python3 .cursor/skills/memory/scripts/load_memory.py",
        "timeout": 10
      }
    ],
    "preCompact": [
      {
        "command": "python3 .cursor/skills/memory/scripts/flush_memory.py",
        "timeout": 5
      }
    ],
    "stop": [
      {
        "command": "python3 .cursor/skills/memory/scripts/prompt_session_save.py",
        "loop_limit": 1
      }
    ],
    "sessionEnd": [
      {
        "command": "python3 .cursor/skills/memory/scripts/sync_and_cleanup.py",
        "timeout": 30
      }
    ]
  }
}
```

### Hook 生命周期与数据流

```
sessionStart ─────────────────────────────────────────────────── sessionEnd
    │                                                                │
    ├─ 加载记忆 → additional_context                                  ├─ sync_index.py（索引同步）
    │                                                                ├─ 记录会话元数据
    │  ┌── preCompact ──┐                                            └─ 清理过期日志
    │  │ 提取事实 prompt  │
    │  │ → user_message  │
    │  └─────────────────┘
    │
    │  ┌── stop ─────────────────────┐
    │  │ 摘要 prompt → followup_msg   │
    │  │ Agent 执行 save_summary.py   │
    │  │ Agent 执行 save_fact.py      │
    │  └──────────────────────────────┘
```

> 完整的配置指南见 [09-用户参与与配置指南](./2026-02-18-09-用户参与与配置指南.md)

---

## 7. 相关文档

- [01-总览与设计理念](./2026-02-18-01-总览与设计理念.md) — 方案概述
- [03-记忆生命周期](./2026-02-18-03-记忆生命周期.md) — 完整会话流程
- [05-SKILL与Rules设计](./2026-02-18-05-SKILL与Rules设计.md) — Agent 行为指导
- [08-SQLite索引设计](./2026-02-18-08-SQLite索引设计.md) — 搜索技术细节
