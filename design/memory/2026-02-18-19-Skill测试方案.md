# Skill 测试方案

## 1. 当前目录结构与角色定义

```
clawd.bot/                              ← 项目根目录
├── skills/                             ← 源码目录（开发、测试在这里）
│   └── memory-skill/
│       ├── lib/                        # Python 库代码
│       ├── scripts/                    # Hook 脚本 + CLI 工具
│       ├── templates/                  # hooks.json, rules, SKILL.md 模板
│       ├── tests/                      # 测试用例 ★ 从这里运行
│       ├── requirements.txt
│       └── SKILL.md                    # 含 {{占位符}} 的模板版本
│
├── .cursor/                            ← 安装目录（Cursor 运行时使用）
│   ├── hooks.json                      # 已替换路径的 Hook 配置
│   ├── rules/memory-rules.mdc          # 已替换路径的 Rules
│   └── skills/
│       ├── memory-skill/               # Python 代码副本（与源码一致）
│       └── memory-data/                # 运行时数据（MEMORY.md, *.jsonl, SQLite）
│
└── 设计/                               ← 测试报告输出位置
    └── 2026-02-18-15-测试报告.md
```

### 职责划分

| 目录 | 职责 | 谁使用 |
|------|------|--------|
| `skills/memory-skill/` | **源码** — 开发、修改、测试 | 开发者 |
| `.cursor/skills/memory-skill/` | **安装副本** — Cursor Hooks 实际执行 | Cursor IDE |
| `.cursor/skills/memory-data/` | **运行数据** — 记忆、索引、日志 | Hooks + Agent |

**核心原则：源码是唯一真实来源（Single Source of Truth），安装版由 `init.py` 自动生成。**

---

## 2. 为什么可以在源码目录测试

### Python 代码完全相同

源码和安装版的 `.py` 文件**完全一致**（`diff` 可验证）。差异仅存在于：

| 文件 | 源码 | 安装版 | 差异原因 |
|------|------|--------|----------|
| `SKILL.md` | `{{SCRIPT_PATH}}/save_fact.py` | `.cursor/skills/memory-skill/scripts/save_fact.py` | Agent 提示用 |
| `templates/hooks.json` | `{{SKILL_PATH}}/scripts/...` | 不保留（写入 `.cursor/hooks.json`） | Hook 命令路径 |
| `templates/memory-rules.mdc` | `{{SCRIPT_PATH}}/...` | 不保留（写入 `.cursor/rules/`） | Rules 命令路径 |

这些差异全部是**文本模板**，不影响 Python 逻辑。

### 路径动态计算机制

所有脚本使用 `__file__` 动态定位自身位置：

```python
# flush_memory.py 中
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
SAVE_FACT_CMD = f"python3 {os.path.join(SCRIPT_DIR, 'save_fact.py')}"
```

- 从源码运行 → `SCRIPT_DIR = .../skills/memory-skill/scripts/`
- 从安装版运行 → `SCRIPT_DIR = .../.cursor/skills/memory-skill/scripts/`

**脚本自适应位置，无需硬编码路径。**

### 数据目录隔离

测试从不使用项目真实的 `.cursor/skills/memory-data/`。每个测试用例：

1. 创建独立的临时目录 `tmpdir`
2. 在其中构建 `.cursor/skills/memory-data/` 结构
3. 通过 `workspace_roots: [tmpdir]` 或 `--project-path tmpdir` 告知脚本数据在哪
4. 测试结束后删除临时目录

```
/tmp/memory-test-xxxx/              ← 每次测试的沙箱
└── .cursor/skills/memory-data/
    ├── MEMORY.md                   ← 测试用的核心记忆
    ├── facts.jsonl                 ← 测试用的事实
    ├── sessions.jsonl              ← 测试用的会话
    └── daily/
        └── 2026-02-18.jsonl        ← 测试用的每日日志
```

---

## 3. 测试分层

```
┌──────────────────────────────────────────────┐
│  第6层  安装验证 (test_init.py)                │  模拟 init.py 全流程
├──────────────────────────────────────────────┤
│  第5层  端到端场景 (test_e2e.py)                │  两轮完整会话 + 搜索
├──────────────────────────────────────────────┤
│  第4层  生命周期集成 (test_context.py)           │  sessionStart→preCompact→stop
├──────────────────────────────────────────────┤
│  第3层  Hook 脚本 (test_load/compact/stop)     │  stdin JSON → stdout JSON
├──────────────────────────────────────────────┤
│  第2层  功能模块 (test_sync/search/chunk)       │  索引同步、搜索引擎、分块
├──────────────────────────────────────────────┤
│  第1层  单元测试 (test_config/jsonl/sqlite)     │  纯函数、数据结构
└──────────────────────────────────────────────┘
```

### 各层具体内容

| 层 | 文件 | 测试项数 | 关注点 |
|----|------|---------|--------|
| 1 | test_config.py | 7 | 配置常量、路径拼接 |
| 1 | test_jsonl.py | 8 | JSONL 读写、衰减加载 |
| 1 | test_sqlite.py | 11 | SQLite CRUD、FTS5、余弦相似度 |
| 2 | test_chunk.py | 9 | 文本分块、Markdown 标题分段、重叠 |
| 2 | test_sync_index.py | 11 | JSONL→SQLite 同步、增量、rebuild |
| 2 | test_search.py | 13 | FTS/vector/hybrid 搜索 |
| 3 | test_load_memory.py | 10 | sessionStart Hook 输入输出 |
| 3 | test_pre_compact.py | 10 | preCompact Hook 输入输出 |
| 3 | test_stop.py | 10 | stop Hook 输入输出 |
| 4 | test_context.py | 10 | 单会话完整流程 |
| 5 | test_e2e.py | 29 | 双会话 + sync + FTS + 向量搜索 |
| 6 | test_init.py | 10 | init.py 安装流程验证 |
| **合计** | **12 文件** | **138** | |

---

## 4. 开发-测试-安装工作流

```
    ┌──────────────┐
    │  修改源码     │  skills/memory-skill/
    └──────┬───────┘
           ▼
    ┌──────────────┐
    │  运行测试     │  python3 skills/memory-skill/tests/run_tests.py
    └──────┬───────┘
           ▼
    ┌──────────────┐
    │  全部通过？   │
    └──┬───────┬───┘
       │ 否    │ 是
       ▼       ▼
    修复代码   ┌──────────────┐
              │  init.py 安装 │  同步到 .cursor/skills/
              └──────┬───────┘
                     ▼
              ┌──────────────┐
              │  diff 验证    │  确认 .py 文件一致
              └──────┬───────┘
                     ▼
              ┌──────────────┐
              │  重启 Cursor  │  Hook 生效
              └──────────────┘
```

### 具体命令

```bash
# === 步骤 1：修改源码 ===
vim skills/memory-skill/scripts/load_memory.py

# === 步骤 2：运行全量测试（约 140s） ===
python3 skills/memory-skill/tests/run_tests.py
# 报告输出: 设计/2026-02-18-15-测试报告.md

# === 步骤 3：确认全部通过后安装 ===
python3 skills/memory-skill/scripts/init.py --skip-model

# === 步骤 4：验证安装一致性 ===
diff -rq skills/memory-skill/ .cursor/skills/memory-skill/ \
  --exclude='__pycache__' --exclude='*.pyc' --exclude='logs'
# 预期输出: 仅 SKILL.md 有差异

# === 步骤 5：重启 Cursor 使 Hook 配置生效 ===
```

---

## 5. 路径问题详解

### 问题：测试中脚本输出的路径是源码路径

当从源码运行 `flush_memory.py` 时，输出的 prompt 中包含：

```
python3 /path/to/skills/memory-skill/scripts/save_fact.py --content "..."
```

而安装后运行时输出的是：

```
python3 /path/to/.cursor/skills/memory-skill/scripts/save_fact.py --content "..."
```

### 为什么这不是问题

这些路径出现在 **Hook 输出的 prompt 文本中**（发给 Agent 的指令），不是由 Hook 脚本自身执行的。测试关注的是：

1. JSON 结构是否正确（`additional_context`、`user_message`、`followup_message`）
2. 内容是否包含必要信息（`[Memory Flush]`、`[Session Save]`）
3. 脚本是否正确读取了数据（MEMORY.md、facts、sessions）
4. 退出码是否符合预期

路径中的绝对前缀不影响逻辑正确性。安装后，同样的代码在不同位置运行时自动产生正确的安装路径。

### 测试中如何模拟数据路径

```python
# test_helper.py 中
def setup(self):
    self.tmp_dir = tempfile.mkdtemp()
    # 模拟 .cursor/skills/memory-data/ 结构
    mem_dir = os.path.join(self.tmp_dir, ".cursor", "skills", "memory-data")
    os.makedirs(os.path.join(mem_dir, "daily"), exist_ok=True)
    # 写入测试数据...

# test_load_memory.py 中
def run(self):
    event = json.dumps({
        "workspace_roots": [self.tmp_dir],  # ← 脚本通过这个定位数据
        "conversation_id": "test-001",
    })
    proc = self.run_script("load_memory.py", stdin_data=event)
```

脚本内部路径计算：
```
workspace_roots[0] = /tmp/memory-test-xxxx/
get_memory_dir()   = /tmp/memory-test-xxxx/.cursor/skills/memory-data/
MEMORY.md          = /tmp/memory-test-xxxx/.cursor/skills/memory-data/MEMORY.md
```

与真实运行时完全一致（只是前缀不同）。

---

## 6. 给其他人安装

### 安装前提

- Python 3.9+
- `sentence-transformers` 依赖（init.py 自动安装）

### 安装命令

```bash
# 克隆源码后，在目标项目中运行：
python3 /path/to/clawd.bot/skills/memory-skill/scripts/init.py \
  --project-path /path/to/target-project

# 或全局安装：
python3 /path/to/clawd.bot/skills/memory-skill/scripts/init.py --global
```

### init.py 执行的操作

1. 创建 `.cursor/skills/memory-skill/` — 复制 Python 代码
2. 创建 `.cursor/skills/memory-data/` — 初始化 MEMORY.md、daily/
3. 合并 `.cursor/hooks.json` — 添加 sessionStart/preCompact/stop
4. 安装 `.cursor/rules/memory-rules.mdc` — Agent 行为规则
5. 替换 SKILL.md 中的 `{{SCRIPT_PATH}}` → 实际安装路径
6. 下载嵌入模型到 `~/.memory-skill/models/`（全局缓存，不重复下载）

### 安装后验证

```bash
# 检查 Hook 配置
cat /path/to/target-project/.cursor/hooks.json

# 手动触发 sessionStart 测试
echo '{"workspace_roots":["/path/to/target-project"]}' | \
  python3 /path/to/target-project/.cursor/skills/memory-skill/scripts/load_memory.py
```

---

## 7. 常见疑问

### Q: 为什么不直接测试 .cursor/skills/ 里的代码？

A: `.cursor/skills/` 是安装产物，如果直接修改会被下次 `init.py` 覆盖。源码才是持久的、版本控制的真实来源。测试源码 = 测试安装后的行为（Python 代码完全一致）。

### Q: 修改源码后忘记 init.py 怎么办？

A: Cursor 使用的是 `.cursor/skills/` 里的旧代码，不会自动更新。建议每次改完源码并通过测试后立即运行 `init.py --skip-model`。

### Q: 测试时嵌入模型加载很慢怎么办？

A: 首次加载约 7 秒（冷启动），后续测试用例共享已加载的模型。如果嵌入模型未安装，向量搜索相关测试会自动跳过（不影响其他测试）。

### Q: 测试报告在哪？

A: `设计/2026-02-18-15-测试报告.md`，每次运行自动覆盖。
