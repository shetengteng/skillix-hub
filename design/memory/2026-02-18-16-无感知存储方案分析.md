# 无感知存储方案分析

> **创建日期**: 2026-02-18
> **背景**: 当前设计中，Agent 需要显式运行 `echo '...' >> file.jsonl` 命令来保存记忆，用户可以在对话中看到这些操作。本文分析如何让存储对用户完全透明。

---

## 1. 当前方案的问题

```
preCompact Hook → flush_memory.py → 返回 user_message
                                   ↓
Agent 收到 "[Memory Flush]" 指令
                                   ↓
Agent 分析对话 → 提取事实 → 执行 echo '...' >> daily.jsonl  ← 用户可见
```

**用户看到的**：Agent 在对话中执行 shell 命令，虽然 Rules 要求静默，但命令执行本身仍然可感知。

---

## 2. 可选方案对比

### 方案 A：当前方案 — Agent 显式写入（echo 命令）

```
Hook → 提示 Agent → Agent 用 shell 写入 JSONL
```

| 优点 | 缺点 |
|------|------|
| 实现简单，已完成 | 用户可在对话中看到 echo 命令 |
| Agent 有完整上下文，提取质量高 | 如果 Agent 忽略指令，数据丢失 |
| 无额外依赖 | 写入格式可能出错（非结构化） |

### 方案 B：封装脚本 — Agent 调用 Python 工具

```
Hook → 提示 Agent → Agent 调用 python3 save_fact.py --content "..." --type W
```

将 `echo` 命令封装为 CLI 工具，Agent 只需传参，不需要构造 JSON：

```bash
# 替代 echo，Agent 只需要：
python3 .cursor/skills/memory-skill/scripts/save_fact.py \
  --content "项目使用 Redis 做缓存" \
  --type W \
  --entities redis,cache \
  --session-id conv-001
```

| 优点 | 缺点 |
|------|------|
| 格式不会出错（脚本内部控制） | 仍然是显式命令，用户可见 |
| 命令更短更清晰 | 需要新增脚本 |
| 参数校验在脚本侧 | 本质上没解决"可见"问题 |

### 方案 C：Hook 双向通信 — Hook 脚本代替 Agent 写入

```
preCompact Hook → flush_memory.py → 返回 user_message（含指令）
Agent 收到指令 → 分析对话 → 返回结构化回复
??? → 如何将 Agent 的回复传回给脚本？
```

**核心问题**：Cursor Hook 目前是**单向**的——Hook 可以向 Agent 注入消息，但无法接收 Agent 的输出。

| 优点 | 缺点 |
|------|------|
| 理论上最透明 | **Cursor 不支持**：无 Hook 回调机制 |
| Agent 不需要执行命令 | 需要 Cursor 平台层面支持 |

**结论**：当前 Cursor 架构下不可行。

### 方案 D：stop Hook 脚本侧写入（部分无感知）

```
stop Hook → prompt_session_save.py → 读取当前对话摘要信息 → 脚本自己写入
```

stop Hook 能拿到的信息：
- `conversation_id`、`status`
- **不能拿到**对话内容（stdin 只有事件元数据）

所以 stop Hook 脚本**不能**自行提取事实或生成摘要——它没有对话上下文。

| 优点 | 缺点 |
|------|------|
| 脚本写入完全透明 | 无法获取对话内容，不能提取事实 |
| - | 只能记录元数据（会话开始/结束时间） |

**结论**：只能做元数据记录，不能替代 Agent 的事实提取。

### 方案 E：Rules 强制静默 + 工具封装（推荐改进）

这是 **方案 A + 方案 B 的结合**，最大化利用现有能力：

```
preCompact Hook → user_message "[Memory Flush]"
                      ↓
Agent 分析对话 → 提取事实 → 调用 python3 save_fact.py（静默执行）
                                                        ↑
                                       Rules: "不在回复中提及记忆操作"
                                       Rules: "在内部工具调用中完成，不向用户展示"
```

**关键改进**：
1. **工具封装**：`save_fact.py` 接受参数，确保格式正确
2. **Rules 强制**：指示 Agent 在工具调用（tool use）中执行，不在回复文本中展示
3. **SKILL.md 指令**：明确要求 "使用工具时不要在回复中提及"

**Agent 的行为差异**：

当前：
```
Agent 回复：好的，我来保存这些信息。
[执行 shell 命令]
echo '{"id":"log-001","type":"fact",...}' >> .cursor/skills/memory-data/daily/2026-02-18.jsonl
```

改进后：
```
Agent 回复：（无任何关于记忆的提及，直接继续正常对话）
[后台工具调用，用户界面不突显]
python3 save_fact.py --content "..." --type W
```

| 优点 | 缺点 |
|------|------|
| 最大程度降低用户感知 | Agent 仍需执行命令（但更短更静默） |
| 格式安全（脚本校验） | 依赖 Agent 遵守 Rules |
| 与现有架构完全兼容 | 在 Cursor UI 中工具调用仍有折叠区域可见 |
| 无需平台改动 | - |

---

## 3. 推荐方案

**方案 E（Rules 强制静默 + 工具封装）** 是当前 Cursor 架构下最优解。

### 需要新增的文件

```
.cursor/skills/memory-skill/scripts/
├── save_fact.py      # CLI: 保存单条事实到 daily.jsonl
└── save_summary.py   # CLI: 保存会话摘要到 sessions.jsonl
```

### save_fact.py 接口设计

```bash
python3 save_fact.py \
  --content "项目使用 Redis 做缓存" \
  --type W \
  --entities "redis,cache" \
  --confidence 0.9 \
  --session "conv-001"
```

脚本内部自动处理：
- 生成 `id`（`log-HHMMSS`）
- 生成 `timestamp`（ISO 8601）
- 构造完整 JSON
- 追加到 `.cursor/skills/memory-data/daily/YYYY-MM-DD.jsonl`
- 输出确认到 stdout（Agent 可捕获但不展示给用户）

### save_summary.py 接口设计

```bash
python3 save_summary.py \
  --topic "技术选型讨论" \
  --summary "讨论了缓存方案，决定使用 Redis" \
  --decisions "使用Redis,TypeScript优先" \
  --todos "实现连接池" \
  --session "conv-001"
```

### Rules 更新

```markdown
## 记忆操作执行方式

当执行 [Memory Flush] 或 [Session Save] 时：
- 使用 save_fact.py / save_summary.py 工具保存，不要使用 echo 命令
- 在执行工具调用时，不要在回复文本中提及
- 不要说"我已保存"、"正在记录"等任何暗示记忆操作的话
- 直接执行，然后继续正常对话
```

---

## 4. 无法实现完全无感知的原因

| 限制 | 说明 |
|------|------|
| Hook 单向通信 | Hook 只能向 Agent 注入消息，无法接收 Agent 输出 |
| 脚本无上下文 | Hook 脚本拿不到对话内容，无法自行提取事实 |
| Agent 必须参与 | 事实提取需要 LLM 推理，必须由 Agent 执行 |
| Agent 执行需要工具 | Agent 保存文件只能通过 Shell 工具，无法直接写文件系统 |

**核心矛盾**：
- 事实提取需要 **Agent 的 LLM 能力**（读懂对话）
- 数据写入需要 **文件系统访问**（Shell 工具）
- 这两者的结合必然产生「Agent 执行 Shell 命令」这一可见行为

**最佳策略**：不追求 100% 无感知，而是通过工具封装 + Rules 静默指令将用户感知降到最低。

---

## 5. 未来可能的完全无感知方案

| 方案 | 前提条件 | 可行性 |
|------|----------|--------|
| Cursor 支持 Hook 双向通信 | 平台升级 | 等待 Cursor 团队 |
| Cursor 支持 Agent 直接写文件（非 Shell） | 平台升级 | 等待 Cursor 团队 |
| MCP Server 作为存储后端 | 自建 MCP Server | 可自行实现（复杂度高） |
| Agent 通过 function calling 写入 | Cursor 支持自定义 function | 等待 Cursor 团队 |

其中 **MCP Server 方案** 是当前技术上可行的完全无感知路线：
- 启动一个本地 MCP Server 提供 `save_memory` 工具
- Agent 通过 MCP tool call 保存记忆
- MCP tool call 在 Cursor UI 中的展示比 Shell 命令更隐蔽
- 但实现复杂度显著增加（需要常驻进程、通信协议等）
