# sessions.jsonl 数据流转与作用说明

> 日期：2026-02-21

---

## 1. sessions.jsonl 是什么

`sessions.jsonl` 是 Memory Skill 中存储**会话摘要**的文件，位于 `memory-data/sessions.jsonl`。每行一条 JSON 记录，代表一次会话的总结信息。

```json
{
  "id": "sum-143005123-a7x2",
  "session_id": "478d20ff-4e1...",
  "topic": "设计 Session Save 优化方案",
  "summary": "讨论了 Memory Skill 的 stop Hook 会额外消耗 Cursor 使用次数的问题，设计了三层防线方案...",
  "decisions": ["采用方案 E2", "引入 session_state 状态文件"],
  "todos": ["实现 Phase 1 基础设施"],
  "timestamp": "2026-02-21T10:30:00Z"
}
```

**核心定位**：它是会话级别的"日记本"，记录每次会话做了什么、决定了什么、还有什么没做完。

---

## 2. 为什么需要 sessions.jsonl

### 2.1 跨会话的上下文连续性

Cursor 的每次会话是独立的——新会话开始时，Agent 不知道上一次会话做了什么。`sessions.jsonl` 解决的核心问题是：

> **让 Agent 在新会话开始时知道"上次我们聊到哪了"。**

### 2.2 与其他存储的区别

Memory Skill 有三种数据存储，各有不同的粒度和用途：

```
┌──────────────────────────────────────────────────────────┐
│                    Memory 数据层次                         │
│                                                          │
│  MEMORY.md          ← 永久核心记忆（用户偏好、项目规范）     │
│  ┆                     粒度：概念级                        │
│  ┆                     生命周期：永久                      │
│  ┆                                                       │
│  sessions.jsonl     ← 会话摘要（每次会话的总结）             │
│  ┆                     粒度：会话级                        │
│  ┆                     生命周期：中期（最近几次会话）         │
│  ┆                                                       │
│  daily/*.jsonl      ← 每日事实（具体的技术决策、代码变更）    │
│                        粒度：事实级                        │
│                        生命周期：短期（衰减加载）            │
└──────────────────────────────────────────────────────────┘
```

| 存储 | 粒度 | 示例 | 谁写入 | 谁读取 |
|------|------|------|--------|--------|
| `MEMORY.md` | 概念 | "用户偏好 TypeScript" | distill_to_memory.py / 手动 | load_memory.py |
| `sessions.jsonl` | 会话 | "上次讨论了 API 重构方案" | save_summary.py | load_memory.py |
| `daily/*.jsonl` | 事实 | "决定使用 PostgreSQL 替代 MySQL" | save_fact.py | load_memory.py / search_memory.py |

---

## 3. 数据流转全景图

```
                        ┌─────────────────┐
                        │   会话开始       │
                        │  (sessionStart)  │
                        └────────┬────────┘
                                 │
                                 ▼
                    ┌────────────────────────┐
                    │    load_memory.py       │
                    │                        │
                    │  读取三个数据源：        │
                    │  1. MEMORY.md          │  ← 永久记忆
                    │  2. daily/*.jsonl      │  ← 近期事实
                    │  3. sessions.jsonl     │  ← 上次会话摘要 ★
                    │                        │
                    │  组装为上下文注入 Agent  │
                    └────────────────────────┘
                                 │
                                 ▼
                    ┌────────────────────────┐
                    │   Agent 工作过程        │
                    │                        │
                    │  用户提问 → Agent 回答  │
                    │  用户提问 → Agent 回答  │
                    │  ...                   │
                    └────────────────────────┘
                                 │
                    ┌────────────┼────────────┐
                    │            │            │
                    ▼            ▼            ▼
            (如果上下文     (任务完成)    (会话关闭)
             接近阈值)
                    │            │            │
                    ▼            ▼            ▼
           ┌──────────────┐ ┌──────────┐ ┌──────────────┐
           │ preCompact   │ │  stop    │ │  sessionEnd  │
           │              │ │  Hook    │ │              │
           │ Agent 保存：  │ │          │ │ 脚本执行：    │
           │ - fact       │ │ 注入提示  │ │ - sync_index │
           │ - 阶段摘要   │ │ Agent 保存│ │ - distill    │
           │              │ │ - summary│ │ - check      │
           │  ↓           │ │ - fact   │ │ - cleanup    │
           │ daily/*.jsonl│ │  ↓       │ │              │
           └──────────────┘ │ sessions │ └──────────────┘
                            │ .jsonl ★ │
                            │ daily/   │
                            └──────────┘
```

---

## 4. sessions.jsonl 在各环节的角色

### 4.1 写入时机：会话结束时

**当前实现**（stop Hook）：

```
Agent 完成任务
  ↓
stop Hook 触发 prompt_session_save.py
  ↓
注入 [Session Save] 提示词
  ↓
Agent 回顾对话，调用 save_summary.py
  ↓
save_summary.py 将摘要追加写入 sessions.jsonl
```

**E2 方案**（三层写入）：

```
第一层：Agent 主动调用 save_summary.py → 写入 sessions.jsonl
第三层：sessionEnd 的 auto_generate_summary() → 写入 sessions.jsonl
第四层：stop Hook 兜底 → Agent 调用 save_summary.py → 写入 sessions.jsonl
```

### 4.2 读取时机：新会话开始时

```python
# load_memory.py 中的关键代码
sessions_path = os.path.join(memory_dir, SESSIONS_FILE)
last_session = read_last_entry(sessions_path)  # 只读最后一条
if last_session:
    topic = last_session.get("topic", "未知")
    summary = last_session.get("summary", "无")
    context_parts.append(
        f"## 上次会话\n\n- 主题：{topic}\n- 摘要：{summary}"
    )
```

**注入到 Agent 上下文的效果**：

```
## 上次会话

- 主题：设计 Session Save 优化方案
- 摘要：讨论了 Memory Skill 的 stop Hook 会额外消耗 Cursor 使用次数的问题...
```

Agent 看到这段上下文后，就知道上次会话的内容，可以自然地延续话题。

### 4.3 间接影响：sessionEnd 的兜底检测

```python
# sync_and_cleanup.py 中
def check_summary_saved(memory_dir, event):
    last = read_last_entry(sessions_path)
    if last and last.get("session_id") == conv_id:
        log.info("摘要已保存")  # 正常
    else:
        log.warning("本次会话未保存摘要")  # 写入警告到 daily log
```

---

## 5. 为什么都写在一个文件里

### 5.1 设计原因

`sessions.jsonl` 采用单文件追加写入（append-only），原因是：

1. **读取简单**：`load_memory.py` 只需要读最后一条（`read_last_entry`），单文件顺序扫描即可
2. **写入简单**：追加一行 JSON，无需创建目录或管理多文件
3. **时间有序**：JSONL 天然按写入顺序排列，最后一条就是最近的会话
4. **体积可控**：每条摘要约 200-500 字节，即使 1000 个会话也只有约 500KB

### 5.2 与 daily/*.jsonl 的对比

| 维度 | sessions.jsonl | daily/*.jsonl |
|------|---------------|---------------|
| 文件策略 | 单文件追加 | 按天分文件 |
| 原因 | 只需读最后一条 | 需要按时间衰减加载，按天分文件便于清理 |
| 读取方式 | `read_last_entry()` | `read_recent_facts_from_daily()` 多文件扫描 |
| 数据量 | 少（每会话 1 条） | 多（每会话 N 条 fact） |
| 清理策略 | 无需清理（体积小） | 可按天删除旧文件 |

### 5.3 当前是否有清理机制？

**没有。** 当前 `sessions.jsonl` 没有任何清理、轮转或截断机制。文件会持续增长。

对比其他存储的清理策略：

| 存储 | 清理机制 | 说明 |
|------|---------|------|
| `daily/*.jsonl` | 按天分文件，可手动删除旧文件 | 加载时有衰减策略（近多远少） |
| `MEMORY.md` | 无自动清理 | 手动维护，体积小 |
| `sessions.jsonl` | **无** | 持续追加，无截断 |
| 日志文件 `logs/*.log` | `clean_old_logs()` 自动清理 | 超过保留天数删除 |

### 5.4 文件持续增长的问题

**增长速度估算**：

- 每条摘要约 300-500 字节
- 假设每天 20 个会话：每天增长约 6-10 KB
- 每月增长约 180-300 KB
- 每年增长约 2-3.6 MB

**实际影响**：

| 会话数 | 文件大小 | `read_last_entry` 耗时 | 影响 |
|--------|---------|----------------------|------|
| 100 | ~50 KB | < 1ms | 无 |
| 1,000 | ~500 KB | < 5ms | 无 |
| 10,000 | ~5 MB | ~50ms | 轻微 |
| 100,000 | ~50 MB | ~500ms | 明显（sessionStart 加载变慢） |

**结论**：在正常使用下（每天 20 个会话），1 年约 7000 条，文件约 3.5 MB，`read_last_entry` 耗时约 35ms，**不构成问题**。

但如果需要长期运行（>2 年）或高频使用，需要考虑清理策略。

### 5.5 可选的清理方案

**方案 1：截断保留最近 N 条**

在 `sessionEnd` 的 `sync_and_cleanup.py` 中增加截断逻辑：

```python
def truncate_sessions(memory_dir: str, keep_last: int = 500):
    """保留最近 N 条摘要，截断旧数据"""
    sessions_path = os.path.join(memory_dir, SESSIONS_FILE)
    if not os.path.exists(sessions_path):
        return
    entries = read_jsonl(sessions_path)
    if len(entries) <= keep_last:
        return
    # 只保留最后 N 条
    kept = entries[-keep_last:]
    with open(sessions_path, "w", encoding="utf-8") as f:
        for e in kept:
            f.write(json.dumps(e, ensure_ascii=False) + "\n")
    log.info("截断 sessions.jsonl: %d → %d 条", len(entries), len(kept))
```

**方案 2：反向读取优化**

不清理文件，但优化 `read_last_entry` 为从文件末尾开始读取：

```python
def read_last_entry_fast(filepath: str):
    """从文件末尾反向读取最后一条有效记录"""
    if not os.path.exists(filepath):
        return None
    with open(filepath, "rb") as f:
        f.seek(0, 2)  # 移到文件末尾
        pos = f.tell()
        lines = []
        while pos > 0:
            pos -= 1
            f.seek(pos)
            char = f.read(1)
            if char == b'\n' and lines:
                line = b''.join(reversed(lines)).decode("utf-8").strip()
                if line:
                    try:
                        entry = json.loads(line)
                        if not entry.get("deleted_at"):
                            return entry
                    except json.JSONDecodeError:
                        pass
                lines = []
            else:
                lines.append(char)
    return None
```

**推荐**：方案 1（截断保留），简单可靠。保留 500 条足够覆盖最近几个月的会话，文件体积控制在 250KB 以内。可以在 E2 方案的 `sync_and_cleanup.py` 中一并实现。

---

## 6. 数据生命周期总览

```
会话 N-2          会话 N-1          会话 N（当前）      会话 N+1（下次）
─────────────────────────────────────────────────────────────────────

[写入]            [写入]            [写入]
save_summary →    save_summary →    save_summary →
sessions.jsonl    sessions.jsonl    sessions.jsonl

save_fact →       save_fact →       save_fact →
daily/02-19.jsonl daily/02-20.jsonl daily/02-21.jsonl

                                                       [读取]
                                                       load_memory.py
                                                       ├── MEMORY.md（永久）
                                                       ├── daily/*.jsonl（衰减）
                                                       └── sessions.jsonl
                                                           └── 只读最后一条
                                                              （= 会话 N 的摘要）

[提炼]
sessionEnd 时 distill_to_memory.py
从 daily/*.jsonl 中筛选高价值 fact → 写入 MEMORY.md
```

**关键理解**：
- `sessions.jsonl` 只有最后一条被使用（上次会话的摘要）
- `daily/*.jsonl` 按衰减策略加载（近多远少）
- `MEMORY.md` 全量加载（永久核心记忆）
- 数据从 daily → MEMORY.md 是单向提炼（高价值事实升级为永久记忆）
- sessions.jsonl 不参与提炼，它的作用仅限于"告诉 Agent 上次做了什么"
