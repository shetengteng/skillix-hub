# 方案 C：测试指南

> **版本**: v1.0
> **创建日期**: 2026-02-18
> **系列**: 方案 C 设计文档 ([返回总览](./2026-02-18-01-总览与设计理念.md))

---

## 1. 手动测试：脚本独立运行

以下命令可在终端直接运行，验证脚本的输入输出是否正确。

### 1.1 测试 load_memory.py（sessionStart）

```bash
cd /Users/TerrellShe/Documents/personal/clawd.bot

echo '{"type":"sessionStart","conversation_id":"test-001","workspace_roots":["/Users/TerrellShe/Documents/personal/clawd.bot"]}' | python3 skills/memory-skill/scripts/load_memory.py
```

**预期输出**：
```json
{"additional_context": "## 核心记忆\n\n# 核心记忆\n..."}
```

**验证点**：
- [x] 输出包含 `additional_context` 字段
- [ ] MEMORY.md 的内容被正确加载
- [ ] 如有 facts.jsonl，近期事实被加载
- [ ] 如有 sessions.jsonl，上次会话被加载
- [ ] `.cursor/skills/memory-data/daily/YYYY-MM-DD.jsonl` 中写入了 session_start 事件

### 1.2 测试 flush_memory.py（preCompact）

```bash
echo '{"type":"preCompact","conversation_id":"test-001","workspace_roots":["/Users/TerrellShe/Documents/personal/clawd.bot"],"context_usage_percent":85,"message_count":30}' | python3 skills/memory-skill/scripts/flush_memory.py
```

**预期输出**：
```json
{"user_message": "[Memory Flush]\n\n上下文即将压缩..."}
```

**验证点**：
- [ ] 输出包含 `user_message` 字段
- [ ] 消息以 `[Memory Flush]` 开头
- [ ] 包含上下文使用率（85%）和消息数（30）
- [ ] 包含正确的日期和时间戳
- [ ] 包含写入命令示例

### 1.3 测试 prompt_session_save.py（stop）

```bash
# status=completed 时应输出 followup_message
echo '{"type":"stop","conversation_id":"test-001","workspace_roots":["/Users/TerrellShe/Documents/personal/clawd.bot"],"status":"completed"}' | python3 skills/memory-skill/scripts/prompt_session_save.py

# status 不是 completed 时应输出空 JSON
echo '{"type":"stop","status":"interrupted"}' | python3 skills/memory-skill/scripts/prompt_session_save.py
```

**预期输出**：
- completed 时：`{"followup_message": "[Session Save]\n\n任务已完成..."}`
- interrupted 时：`{}`

**验证点**：
- [ ] completed 输出包含 `followup_message`
- [ ] 消息以 `[Session Save]` 开头
- [ ] interrupted 输出为空 JSON `{}`

---

## 2. 集成测试：Hook 真实触发

### 2.1 前置条件

确认以下文件已正确安装：

```bash
# 检查 hooks.json
cat .cursor/hooks.json

# 检查 rules
cat .cursor/rules/memory-rules.mdc

# 检查 MEMORY.md
cat .cursor/skills/memory-data/MEMORY.md
```

### 2.2 测试 sessionStart Hook

**步骤**：
1. 关闭当前 Cursor 会话
2. 重新打开项目或开始新对话
3. 观察 Agent 的第一条回复

**预期结果**：
- Agent 的响应暗示它"知道"项目信息（来自 MEMORY.md）
- `.cursor/skills/memory-data/daily/YYYY-MM-DD.jsonl` 中新增了 `session_start` 记录

**验证命令**：
```bash
cat .cursor/skills/memory-data/daily/$(date +%Y-%m-%d).jsonl
```

### 2.3 测试 preCompact Hook（需要长对话触发）

**步骤**：
1. 进行一段较长的对话（需要接近上下文上限）
2. 等待 preCompact 自动触发

**替代方法**：如果无法触发，可以手动创建测试 Hook：

```json
{
  "version": 1,
  "hooks": {
    "preCompact": [
      {
        "command": "python3 skills/memory-skill/scripts/flush_memory.py",
        "timeout": 5
      }
    ]
  }
}
```

**预期结果**：
- Agent 静默将事实写入 `.cursor/skills/memory-data/daily/YYYY-MM-DD.jsonl`
- 用户不会看到任何关于记忆操作的提示

**验证命令**：
```bash
cat .cursor/skills/memory-data/daily/$(date +%Y-%m-%d).jsonl | python3 -m json.tool --no-ensure-ascii
```

### 2.4 测试 stop Hook

**步骤**：
1. 让 Agent 完成一个简单任务（如"帮我列出当前目录的文件"）
2. Agent 完成任务后，stop Hook 应自动触发

**预期结果**：
- `.cursor/skills/memory-data/sessions.jsonl` 中新增一条会话摘要
- 如果是短会话（preCompact 未触发），daily.jsonl 中也应有事实记录

**验证命令**：
```bash
cat .cursor/skills/memory-data/sessions.jsonl | python3 -m json.tool --no-ensure-ascii
```

---

## 3. 跨会话测试

### 3.1 测试记忆延续

**步骤**：
1. 在会话 A 中讨论一个特定话题（如"我们决定使用 Redis 做缓存"）
2. 等待 stop Hook 保存摘要
3. 关闭会话 A
4. 开始新的会话 B
5. 询问"我们之前决定用什么做缓存？"

**预期结果**：
- 会话 B 中 Agent 能回答"Redis"（因为 sessionStart 加载了会话 A 的摘要）

### 3.2 验证数据文件

每次测试后检查数据文件的完整性：

```bash
# 检查所有数据文件
echo "=== MEMORY.md ==="
cat .cursor/skills/memory-data/MEMORY.md
echo ""
echo "=== daily ==="
ls -la .cursor/skills/memory-data/daily/
echo ""
echo "=== sessions.jsonl ==="
cat .cursor/skills/memory-data/sessions.jsonl 2>/dev/null || echo "(empty)"
echo ""
echo "=== facts.jsonl ==="
cat .cursor/skills/memory-data/facts.jsonl 2>/dev/null || echo "(empty)"
```

---

## 4. 关键假设验证清单

| 编号 | 假设 | 验证方式 | 状态 |
|------|------|----------|------|
| H1 | preCompact 的 `user_message` 被 Agent 接收并执行 | 测试 2.3 | 待验证 |
| H2 | `user_message` 在压缩**前**注入（Agent 仍有完整上下文） | 让 Agent 报告当前对话消息数 | 待验证 |
| H3 | stop 的 `followup_message` 能让 Agent 继续执行一轮 | 测试 2.4 | 待验证 |
| H4 | Agent 按照 SKILL.md 的格式写入 JSONL | 检查写入的 JSONL 格式 | 待验证 |
| H5 | Rules 能有效强制 Agent 响应 flush 指令 | 对比有/无 Rules 的行为差异 | 待验证 |

---

## 5. 问题排查

### Hook 脚本没有被触发

```bash
# 检查 hooks.json 是否存在且格式正确
python3 -m json.tool .cursor/hooks.json

# 手动运行脚本确认无报错
echo '{}' | python3 skills/memory-skill/scripts/load_memory.py
```

### Agent 没有执行 [Memory Flush] 指令

1. 检查 Rules 文件是否存在：`cat .cursor/rules/memory-rules.mdc`
2. 检查 SKILL.md 是否存在：`cat skills/memory-skill/SKILL.md`
3. 确认 Agent 能看到 SKILL.md（在对话中询问"你是否加载了 memory-skill？"）

### JSONL 格式错误

```bash
# 验证每一行都是有效 JSON
python3 -c "
import json, sys
for i, line in enumerate(open('.cursor/skills/memory-data/daily/$(date +%Y-%m-%d).jsonl'), 1):
    try: json.loads(line)
    except: print(f'Line {i} invalid: {line.strip()[:50]}')
print('All valid' if i else 'Empty file')
"
```

---

## 相关文档

- [10-风险与验证计划](./2026-02-18-10-风险与验证计划.md) — 详细的验证策略
- [12-开发实现指南](./2026-02-18-12-开发实现指南.md) — 各脚本的输入输出规格
