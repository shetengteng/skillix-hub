# Memory Skill 真实 Cursor 环境测试用例

> **日期**: 2026-02-19
> **目的**: 从用户自然语言交互的角度，验证 Memory Skill 在真实 Cursor 中的完整工作流程
> **源码**: `skills/memory/scripts/`
> **数据目录**: `.cursor/skills/memory-data/`

---

## 1. 安装与初始化

### TC-1.1 通过自然语言安装

**用户输入**:
```
帮我从 https://github.com/shetengteng/skillix-hub 安装 memory skill
```

**预期 Agent 行为**:
1. 克隆仓库
2. 复制 `skills/memory` 到 `~/.cursor/skills/`
3. 执行 `python3 ~/.cursor/skills/memory/scripts/service/init/index.py`

**预期 Agent 回复**（示意）:
```
正在安装 Memory Skill...

1. 克隆仓库到临时目录
2. 复制 skills/memory 到 ~/.cursor/skills/
3. 运行初始化脚本

✅ Memory Skill 安装成功！

已配置：
• sessionStart Hook → 新会话开始时自动加载记忆
• preCompact Hook → 上下文压缩前保存关键事实
• stop Hook → 会话结束时保存摘要
• memory-rules.mdc → 引导 Agent 执行记忆操作
```

**验证**:
- [x] `.cursor/hooks.json` 包含 sessionStart / preCompact / stop 三个 Hook
- [x] `.cursor/rules/memory-rules.mdc` 存在
- [x] `.cursor/skills/memory-data/` 目录已创建
- [x] `.cursor/skills/memory-data/MEMORY.md` 已创建

```bash
cat .cursor/hooks.json | python3 -m json.tool
ls -la .cursor/rules/memory-rules.mdc
ls -la .cursor/skills/memory-data/
```

---

## 2. 自动记忆加载（sessionStart）

### TC-2.1 新会话开始时自动加载

**前置准备**: 在 `MEMORY.md` 中写入：
```markdown
# 核心记忆
- 项目使用 FastAPI + PostgreSQL
- 用户偏好 Python 和 TypeScript
```

**用户输入**（新会话开始后的第一句话）:
```
继续昨天的 API 开发
```

**预期 Agent 回复**（示意）:
```
（sessionStart Hook 已自动加载记忆上下文）

根据之前的记忆，你的项目使用 FastAPI + PostgreSQL 架构。

让我看看上次的进度... 上次会话我们讨论了用户认证模块。
需要我从哪里继续？
```

**会话 demo**:

| 角色 | 内容 |
|------|------|
| **系统** | _(sessionStart Hook 自动触发，load_memory.py 返回 MEMORY.md + 近期事实 + 上次摘要)_ |
| **用户** | 继续昨天的 API 开发 |
| **Agent** | 根据记忆，你的项目使用 FastAPI + PostgreSQL。上次我们完成了用户模块的 CRUD。今天要继续哪个模块？ |
| **用户** | 做订单模块吧 |
| **Agent** | 好的，开始设计订单模块的 API... |

**验证**:
- [x] Agent 的回复体现了对项目的"已有认知"
- [x] daily/ 目录下当天 JSONL 新增 `session_start` 记录

---

## 3. 事实自动保存（preCompact）

### TC-3.1 长对话中自动保存事实

**场景**: 与 Agent 进行较长对话，讨论多个技术决策。当上下文接近压缩阈值时，preCompact Hook 自动触发。

**会话 demo**:

| 角色 | 内容 |
|------|------|
| **用户** | 帮我设计订单模块 |
| **Agent** | 好的，订单模块需要以下表... |
| **用户** | 订单状态用枚举，不要用字符串 |
| **Agent** | 明白，使用 Enum 类型... |
| **用户** | 数据库用 PostgreSQL 的 ENUM 类型 |
| **Agent** | 好的，使用 PostgreSQL 的原生 ENUM... |
| _...多轮对话..._ | |
| **系统** | _(preCompact Hook 触发，flush_memory.py 注入 [Memory Flush] 消息)_ |
| **Agent** | _(静默执行，用户不可见)_ 回顾对话，提取事实：<br>• `save_fact --content "订单状态使用 PostgreSQL ENUM 类型" --type W`<br>• `save_fact --content "用户偏好强类型约束" --type O --confidence 0.85` |
| **用户** | _(继续正常对话，不感知上述操作)_ |

**预期**: Agent 静默保存，用户不会看到任何关于记忆操作的提示。

**验证**:
```bash
tail -5 .cursor/skills/memory-data/daily/$(date +%Y-%m-%d).jsonl | python3 -m json.tool
```
- [ ] 新增的事实条目包含 content / type / entities
- [ ] 用户对话流程不受影响

---

## 4. 会话摘要保存（stop）

### TC-4.1 任务完成后自动保存摘要

**会话 demo**:

| 角色 | 内容 |
|------|------|
| **用户** | 好的，订单模块做完了，今天就到这里 |
| **Agent** | 好的！今天我们完成了订单模块的设计和实现，包括...<br><br>再见！ |
| **系统** | _(stop Hook 触发，prompt_session_save.py 注入 [Session Save] 消息)_ |
| **Agent** | _(静默执行)_ `save_summary --topic "订单模块开发" --summary "设计并实现了订单CRUD API..." --decisions "使用ENUM,分页用Cursor" --todos "添加支付集成,编写测试"` |

**验证**:
```bash
tail -1 .cursor/skills/memory-data/sessions.jsonl | python3 -m json.tool
```
- [ ] 新增一条包含 topic / summary / decisions / todos 的摘要
- [ ] 下次新会话开始时，Agent 能引用这个摘要

---

## 5. 用户主动操作

### TC-5.1 手动记住信息

**用户输入**:
```
记住这个：我们的代码规范要求所有函数必须有 docstring
```

**预期 Agent 行为**: 直接编辑 `MEMORY.md`，追加这条信息。

**会话 demo**:

| 角色 | 内容 |
|------|------|
| **用户** | 记住这个：我们的代码规范要求所有函数必须有 docstring |
| **Agent** | 已记录到核心记忆中。以后我会确保所有函数都包含 docstring。 |

**验证**:
```bash
cat .cursor/skills/memory-data/MEMORY.md
```
- [ ] 文件末尾包含 docstring 规范的记录

### TC-5.2 搜索记忆

**用户输入**:
```
搜索一下我们之前关于数据库的讨论
```

**会话 demo**:

| 角色 | 内容 |
|------|------|
| **用户** | 搜索一下我们之前关于数据库的讨论 |
| **Agent** | 搜索记忆中...<br><br>找到 3 条相关记忆：<br><br>1. [W] 项目使用 PostgreSQL 数据库（0.95）<br>   日期: 2026-02-18<br><br>2. [W] 订单状态使用 PostgreSQL ENUM 类型（0.9）<br>   日期: 2026-02-19<br><br>3. [S] 会话摘要：数据库选型讨论<br>   日期: 2026-02-16 |

### TC-5.3 管理记忆

**用户输入**:
```
帮我看一下记忆统计
```

**会话 demo**:

| 角色 | 内容 |
|------|------|
| **用户** | 帮我看一下记忆统计 |
| **Agent** | 📊 记忆统计<br><br>• 核心记忆: 856 字符<br>• 事实记录: 47 条（W:28 / B:11 / O:8）<br>• 会话摘要: 12 条<br>• 最近 7 天活跃<br>• 磁盘: 156 KB |

### TC-5.4 删除记忆

**用户输入**:
```
删除关于 MySQL 的记忆
```

**会话 demo**:

| 角色 | 内容 |
|------|------|
| **用户** | 删除关于 MySQL 的记忆 |
| **Agent** | 搜索包含 "MySQL" 的记忆...<br><br>找到 2 条：<br>1. [W] 旧项目使用 MySQL 5.7 (2026-02-15)<br>2. [W] MySQL 连接配置 (2026-02-15)<br><br>已删除 2 条记忆，索引已更新。 |

---

## 6. 跨会话记忆验证

### TC-6.1 完整跨会话测试

**会话 A**:

| 角色 | 内容 |
|------|------|
| **用户** | 我们决定用 Redis 做缓存层，TTL 设为 300 秒 |
| **Agent** | 好的，使用 Redis 缓存，TTL 300 秒。我来配置... |
| **用户** | 好了，今天就到这 |
| **Agent** | 再见！_(stop Hook 自动保存摘要)_ |

**会话 B（新开一个对话）**:

| 角色 | 内容 |
|------|------|
| **系统** | _(sessionStart Hook 加载记忆)_ |
| **用户** | 我们之前决定用什么做缓存？TTL 是多少？ |
| **Agent** | 根据之前的记忆，你们决定使用 **Redis** 做缓存层，**TTL 设为 300 秒**。 |

**验证**:
- [ ] 会话 B 的 Agent 能准确回答 Redis 和 300 秒

---

## 7. 边界场景

### TC-7.1 空项目（无任何记忆）

**用户输入**（新项目，首次使用）:
```
这个项目用什么技术栈？
```

**预期**: Agent 不会编造记忆，而是表示没有相关信息或询问用户。

### TC-7.2 interrupted 会话不保存

**场景**: 用户中途关闭 Cursor 窗口。

**预期**: stop Hook 收到 `status: interrupted`，不生成 `followup_message`，不保存摘要。

### TC-7.3 短会话的事实补充

**场景**: 短会话（preCompact 未触发），但 stop Hook 检测到 completed。

**预期**: Agent 在保存摘要的同时，也用 `save_fact` 提取会话中的关键事实。

---

## 8. 数据完整性检查

每次测试后运行：

```bash
# 检查核心记忆
echo "=== MEMORY.md ==="
cat .cursor/skills/memory-data/MEMORY.md

# 检查今日事实
echo "=== daily ==="
cat .cursor/skills/memory-data/daily/$(date +%Y-%m-%d).jsonl 2>/dev/null | python3 -m json.tool || echo "(empty)"

# 检查会话摘要
echo "=== sessions ==="
cat .cursor/skills/memory-data/sessions.jsonl 2>/dev/null | python3 -m json.tool || echo "(empty)"

# 验证 JSONL 格式
for f in .cursor/skills/memory-data/daily/*.jsonl .cursor/skills/memory-data/sessions.jsonl; do
  [ -f "$f" ] && python3 -c "
import json
with open('$f') as fh:
    lines = [l for l in fh if l.strip()]
    errors = [i for i,l in enumerate(lines,1) if not l.strip()]
    for i,l in enumerate(lines,1):
        try: json.loads(l)
        except: errors.append(i)
    print(f'{len(lines)} lines, errors: {errors or \"none\"}  [{f}]')
"
done
```
